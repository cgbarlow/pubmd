# Mermaid Diagram Rendering Failure in Playwright PDF Output

## Problem Statement

The `PdfService`, when utilizing the `PlaywrightPdfEngine`, fails to render Mermaid diagrams in the generated PDF. The `MarkdownService` correctly produces HTML that includes an SVG representation of the Mermaid diagram. This SVG is generated by Mermaid.js within a JSDOM environment.

Key characteristics of the problematic SVG generated by `MarkdownService`:
*   It uses `<foreignObject>` elements for rendering text labels within the diagram (e.g., node names, edge labels). This is a default behavior of Mermaid.js for the "default" theme when `htmlLabels` is not explicitly set to `false` for flowchart-like diagrams.
*   These `<foreignObject>` elements are consistently generated with `width="0"` and `height="0"` attributes by the JSDOM-based rendering process.
*   The `viewBox` attribute of the main SVG often indicates a very small height (e.g., 40 units relative to a much larger width), suggesting a highly compressed layout or inaccurate bounding box calculations from the JSDOM environment.
*   Some SVG groups for labels (specifically `edgeLabel` groups) have `transform="translate(undefined, NaN)"` attributes, which will prevent their rendering.

When this HTML (containing such an SVG) is passed to `PlaywrightPdfEngine`:
*   The rest of the Markdown content is correctly converted to PDF.
*   The area designated for the Mermaid diagram appears blank in the final PDF.
*   Screenshots taken by Playwright before PDF generation also show a blank area for the diagram, indicating the rendering issue occurs within Playwright's Chromium browser context itself, not just during PDF conversion.
*   The root cause appears to be that Playwright/Chromium cannot render the content of `<foreignObject>` elements that have zero dimensions, and potentially also struggles with the `NaN` transforms and the extremely compressed `viewBox`.

**Constraints:**
*   The `MarkdownService` implementation, which produces this specific SVG structure, must remain unchanged.
*   The `PdfService` and its `PlaywrightPdfEngine` should consume the HTML artifact from `MarkdownService` as-is, without re-interpreting raw Markdown or injecting client-side rendering scripts like Mermaid.js directly into Playwright (to maintain the architectural separation of concerns and reusability of `MarkdownService`'s output).

The challenge is to make the JSDOM-generated, `<foreignObject>`-heavy, and dimensionally problematic SVG render correctly within Playwright's PDF generation process, solely by manipulating the existing DOM within Playwright or by adjusting Playwright's rendering options, without altering the input HTML string's fundamental structure as received from `MarkdownService`.

## Table of Contents

* [Background](#background)
* [Attempted Fixes](#attempted-fixes)
* [Hypothesis](#hypothesis)
* [Prior Research](#prior-research)
  * [Learnings: Integrating Mermaid.js and DOMPurify in a Node.js Environment](#learnings-integrating-mermaidjs-and-dompurify-in-a-nodejs-environment)
  * [Issue Research: test-pdf-service, JSDOM, ESM build, html2canvas](#issue-research-test-pdf-service-jsdom-esm-build-html2canvas)
* [Dependencies](#dependencies)
  * [nodejs_projects/core/src/services/pdf/playwright.engine.ts](#nodejs_projectscoresrcservicespdfplaywrightenginets)
  * [nodejs_projects/core/src/services/markdown/markdown.service.ts](#nodejs_projectscoresrcservicesmarkdownmarkdownservicets)
  * [nodejs_projects/core/scripts/test-pdf-service.mjs](#nodejs_projectscorescriptstest-pdf-servicemjs)
  * [nodejs_projects/core/scripts/debug_markdown_service_output.html](#nodejs_projectscorescriptsdebug_markdown_service_outputhtml)
  * [nodejs_projects/core/scripts/bootstrap-mermaid.mjs](#nodejs_projectscorescriptsbootstrap-mermaidmjs)

## Background

The project requires converting Markdown documents, which may include Mermaid diagrams, into PDF files. The `MarkdownService` is responsible for parsing Markdown text into HTML. For Mermaid diagrams, it uses the Mermaid.js library within a JSDOM environment to generate SVG representations of the diagrams. This SVG is then embedded in the resulting HTML. The `PdfService`, specifically its `PlaywrightPdfEngine`, takes this HTML and uses Playwright (a headless browser automation library) to render the HTML and convert it to a PDF.

Early development showed that while standard Markdown elements rendered correctly, Mermaid diagrams were consistently missing or appearing as blank spaces in the PDF output. Investigation revealed that the JSDOM environment, lacking a true rendering engine, requires polyfills for certain browser functionalities like `SVGElement.prototype.getBBox()`. Mermaid.js relies on these for layout calculations. The SVGs generated in JSDOM, particularly those using `<foreignObject>` for text labels (a default for some themes/diagram types), often have incorrect or zero dimensions for these `foreignObject` elements, and sometimes malformed transform attributes.

## Attempted Fixes

1.  **Initial `fakeBBox` Polyfill:** Implemented a basic `fakeBBox` function in the JSDOM setup for `MarkdownService` to simulate `getBBox()` calls. This allowed Mermaid to generate an SVG structure but did not resolve the rendering issue in Playwright.
2.  **Adjusted `fakeBBox` Dimensions:** Experimented with different return values (width and height calculations) for `fakeBBox`. While this affected the `viewBox` of the generated SVG, the diagram content remained unrendered.
3.  **Playwright `waitUntil` Options:** Switched `page.setContent()` from `waitUntil: 'networkidle'` to `waitUntil: 'domcontentloaded'`, as content is local. No impact on diagram rendering.
4.  **Simplified HTML for Playwright Debugging:** Isolated the Mermaid SVG in a minimal HTML page and provided explicit dimensions and borders to the SVG and its container via CSS. This confirmed that Playwright rendered the containers but not the SVG's internal content.
5.  **Playwright Screenshot Debugging:** Took PNG screenshots before PDF generation. These screenshots matched the PDF output (blank diagram area), confirming the issue lies in Playwright's rendering of the SVG, not the PDF conversion step itself.
6.  **Alignment with `bootstrap-mermaid.mjs`:** Modified the `fakeBBox` implementation and its application in the JSDOM setup (`test-pdf-service.mjs`) to align with a previously successful standalone Mermaid rendering script (`bootstrap-mermaid.mjs`). This involved using specific dimensions (height 16, width multiplier 8) and applying the polyfill to a specific list of SVG element prototypes. This did not resolve the blank diagram issue.
7.  **Inspection of Generated SVG:** Analysis of the `debug_markdown_service_output.html` (output from `MarkdownService`) revealed that `<foreignObject>` elements used for labels consistently have `width="0" height="0"`, and some `edgeLabel` groups have `transform="translate(undefined, NaN)"`.

## Hypothesis

The primary reason for the blank Mermaid diagrams in Playwright's PDF output is the `width="0" height="0"` attributes on `<foreignObject>` elements within the SVG. A secondary contributing factor might be malformed `transform` attributes (e.g., containing `NaN`) on some label groups. If Playwright's rendering engine encounters `<foreignObject>` elements with zero dimensions, it likely does not render their content, even if the inner HTML content of the `foreignObject` would normally occupy space. Correcting these dimensions dynamically within Playwright's browser context, based on the actual size of the inner content, might allow the diagrams to be rendered.

## Prior Research

This section includes summaries of previous research and learning documents relevant to the challenges of rendering complex HTML, particularly involving Mermaid.js and DOMPurify, in Node.js environments.

### Learnings: Integrating Mermaid.js and DOMPurify in a Node.js Environment

*Source: `documentation/03_Implementation/learnings_mermaid_dompurify_nodejs.md`*

This document details the integration of Mermaid.js and DOMPurify in Node.js for the `MarkdownService`. Key challenges included Mermaid's expectation of a global `DOMPurify` object, JSDOM's lack of `getBBox()`, the need for global DOM types (e.g., `Element`), and complexities with DOMPurify's ESM module.

**Solutions involved:**
*   **DOMPurify Handling**: Creating a single JSDOM-aware `DOMPurifyInstance`, patching the imported DOMPurify module to use this instance, and providing a `globalThis.DOMPurify` shim.
*   **Layout**: Implementing a `fakeBBox` polyfill for SVG elements.
*   **JSDOM Environment**: Explicitly globalizing essential DOM types from the JSDOM `window`.

The final `bootstrap-mermaid.mjs` script encapsulates these solutions, including intelligent DOMPurify import handling, JSDOM setup, the `fakeBBox` polyfill, unified DOMPurify instance management, and specific Mermaid configurations (like `securityLevel: 'strict'` and `flowchart: { htmlLabels: false }`).

**Key Takeaways**:
*   Explicit globalization of JSDOM properties can be necessary.
*   Patching imported modules is crucial if libraries cache dependencies.
*   JSDOM limitations require polyfills (e.g., `getBBox`).

### Issue Research: test-pdf-service, JSDOM, ESM build, html2canvas

*Source: `documentation/03_Implementation/issue_research_test-pdf-service_JSDOM_ESMbuild_html2canvas.md`*

This document advocates for a `PdfService` that uses a headless browser (Playwright/Puppeteer) to print HTML to PDF, rather than JSDOM + html2canvas, to achieve better fidelity with CSS, SVG, and MathJax, and to avoid brittle polyfills.

**Core Ideas**:
*   **HTML-first Approach**: Maintain `MarkdownService`'s role in producing sanitized HTML as the single source of truth.
*   **`PdfService` Redesign**:
    *   Employ a strategy pattern with an `IPdfEngine`.
    *   Recommend `PlaywrightEngine` as the default, utilizing Chromium's native PDF generation.
*   **Implications**:
    *   `MarkdownService` remains largely unchanged.
    *   The extensive JSDOM bootstrap polyfill for PDF generation could be significantly reduced, as Playwright provides the browser environment. The JSDOM setup for `MarkdownService` itself (for Mermaid rendering to SVG) would still need its focused polyfills (like `fakeBBox` and DOMPurify setup).

The document suggests that this approach (using Playwright for PDF) leverages the strengths of real browser engines for rendering, while keeping the `MarkdownService` focused on Markdown-to-HTML (including Mermaid SVG) conversion.

## Dependencies

### nodejs_projects/core/src/services/pdf/playwright.engine.ts
```typescript
// Buffer is expected to be a global type from @types/node
import { IPdfEngine } from './pdf-engine.interface.js';
import { PdfGenerationOptions } from './pdf.types.js';
import { chromium, Browser, Page, errors as PlaywrightErrors } from 'playwright';

export class PlaywrightPdfEngine implements IPdfEngine {
  public async generate(html: string, options: PdfGenerationOptions): Promise<Blob> {
    console.log('PlaywrightPdfEngine.generate called with options:', options);
    let browser: Browser | null = null;
    try {
      browser = await chromium.launch();
      const context = await browser.newContext();
      const page: Page = await context.newPage();

      await page.setContent(html, { waitUntil: 'domcontentloaded' });

      const playwrightPdfOptions: any = {
        format: options.pageFormat || 'A4',
        landscape: options.orientation === 'landscape',
        scale: options.scale || 1, // Corrected typo here
        margin: {
          top: options.margins?.top ? `${options.margins.top}mm` : '10mm',
          right: options.margins?.right ? `${options.margins.right}mm` : '10mm',
          bottom: options.margins?.bottom ? `${options.margins.bottom}mm` : '10mm',
          left: options.margins?.left ? `${options.margins.left}mm` : '10mm',
        },
        printBackground: options.printBackground === undefined ? true : options.printBackground,
      };

      if (options.width) {
        playwrightPdfOptions.width = options.width;
      }
      if (options.height) {
        playwrightPdfOptions.height = options.height;
      }
      if (options.path) {
        playwrightPdfOptions.path = options.path;
      }

      const pdfBuffer: Buffer = await page.pdf(playwrightPdfOptions);

      await browser.close();
      browser = null;

      return new Blob([pdfBuffer], { type: 'application/pdf' });

    } catch (error) {
      console.error('Error in PlaywrightPdfEngine.generate:', error);
      if (browser) {
        try {
          await browser.close();
        } catch (closeError) {
          console.error('Error closing browser after an initial error:', closeError);
        }
      }
      if (error instanceof PlaywrightErrors.TimeoutError) {
        throw new Error(`Playwright timed out: ${error.message}`);
      }
      throw new Error(`Failed to generate PDF with Playwright: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}
```

### nodejs_projects/core/src/services/markdown/markdown.service.ts
```typescript
import { marked, Renderer, Tokens } from 'marked';
import mermaid from 'mermaid';
// DOMPurify is no longer imported directly. It's expected to be on globalThis.
import { IMarkdownService, MarkdownParseOptions, MermaidTheme, MermaidSecurityLevel } from './markdown-types.js';

const DEFAULT_MARKDOWN_PARSE_OPTIONS: Required<Omit<MarkdownParseOptions, 'mermaidTheme' | 'mermaidSecurityLevel'>> & Pick<MarkdownParseOptions, 'mermaidTheme' | 'mermaidSecurityLevel'> = {
    gfm: true,
    breaks: true,
    headerIds: true,
    sanitizeHtml: true,
    mermaidTheme: 'default' as MermaidTheme,
    mermaidSecurityLevel: 'loose' as MermaidSecurityLevel,
};

const escape = (html: string, encode?: boolean): string => {
    return html
      .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&')
      .replace(/</g, '<')
      .replace(/>/g, '>')
      .replace(/"/g, '"')
      .replace(/'/g, '\u0027');
};

export class MarkdownService implements IMarkdownService {
    constructor() {
        // JSDOM and global DOMPurify instance should be set up by the environment
        // (e.g., test script or main application bootstrap) for server-side Mermaid rendering
        // and for the service's own sanitization needs if sanitizeHtml is true.
    }

    public async parse(markdownText: string, options?: MarkdownParseOptions): Promise<string> {
        const mergedOptions = { ...DEFAULT_MARKDOWN_PARSE_OPTIONS, ...options };

        // Ensure globalThis.DOMPurify is available if sanitization is needed by this service or by Mermaid
        const currentDOMPurify = (globalThis as any).DOMPurify;
        if (mergedOptions.sanitizeHtml && (!currentDOMPurify || typeof currentDOMPurify.sanitize !== 'function')) {
            console.warn("MarkdownService: sanitizeHtml is true, but globalThis.DOMPurify.sanitize is not available. HTML will not be sanitized by the service for non-Mermaid code blocks.");
            // Potentially throw an error or disable sanitization for code blocks
        }
        if ((mergedOptions.mermaidSecurityLevel !== 'loose' && mergedOptions.mermaidSecurityLevel !== 'antiscript') && // strict or sandbox
            (!currentDOMPurify || typeof currentDOMPurify.sanitize !== 'function')) {
            // Mermaid will also log an error or fail if it can't find globalThis.DOMPurify.sanitize
            console.warn("MarkdownService: Mermaid security level requires DOMPurify, but globalThis.DOMPurify.sanitize is not available.");
        }


        if (typeof mermaid.initialize === 'function') {
            mermaid.initialize({
                startOnLoad: false,
                theme: mergedOptions.mermaidTheme,
                securityLevel: mergedOptions.mermaidSecurityLevel,
                // Mermaid v11+ uses its imported DOMPurify or globalThis.DOMPurify.
                // The globalThis.DOMPurify should be configured by the environment.
                dompurifyConfig: {
                    USE_PROFILES: { html: true, svg: true },
                }
            });
        }

        const renderer = new Renderer();
        const mermaidPlaceholders: { id: string, code: string, placeholderRegex: RegExp, placeholderString: string }[] = [];

        renderer.code = (token: Tokens.Code): string => {
            const lang = (token.lang || '').toLowerCase();
            if (lang === 'mermaid') {
                const uniqueId = `mermaid-svg-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
                const placeholderString = `<!-- MERMAID_PLACEHOLDER_${uniqueId} -->`;
                mermaidPlaceholders.push({
                    id: uniqueId,
                    code: token.text,
                    placeholderRegex: new RegExp(placeholderString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')),
                    placeholderString: placeholderString
                });
                return placeholderString;
            }

            const classAttribute = lang ? ` class="language-${escape(lang, true)}"` : '';
            const codeToDisplay = token.escaped ? token.text : escape(token.text, true);
            let rawHtml = `<pre><code${classAttribute}>${codeToDisplay}\n</code></pre>\n`;

            if (mergedOptions.sanitizeHtml && currentDOMPurify && typeof currentDOMPurify.sanitize === 'function') {
                // Use the globally provided DOMPurify instance
                return currentDOMPurify.sanitize(rawHtml, {
                    USE_PROFILES: { html: true },
                    ADD_TAGS: ['pre', 'code'],
                    ADD_ATTR: ['class']
                });
            }
            // If sanitizeHtml is true but DOMPurify is not available, rawHtml is returned (with a warning logged earlier)
            // If sanitizeHtml is false, rawHtml is returned.
            return rawHtml;
        };

        marked.use({ renderer });

        const markedOptions = {
            gfm: mergedOptions.gfm,
            breaks: mergedOptions.breaks,
            headerIds: mergedOptions.headerIds,
            mangle: false,
        };

        let html = await Promise.resolve(marked.parse(markdownText, markedOptions));
        if (typeof html !== 'string') {
            html = String(html);
        }

        if (typeof mermaid.render === 'function' && mermaidPlaceholders.length > 0) {
            for (const item of mermaidPlaceholders) {
                try {
                    const { svg } = await mermaid.render(item.id, item.code);
                    // Mermaid's output (SVG) is assumed to be safe if securityLevel is not 'unsafe',
                    // as it would have used the global DOMPurify.
                    html = html.replace(item.placeholderRegex, `<div class="mermaid">${svg}</div>`);
                } catch (e: any) {
                    console.error(`Mermaid rendering error for diagram starting with "${item.code.substring(0, 30)}...":`, e);
                    const errorHtml = `<pre class="mermaid-error" data-mermaid-id="${item.id}">Mermaid Error: ${escape(e.message || String(e))}</pre>`;
                    html = html.replace(item.placeholderRegex, errorHtml);
                }
            }
        } else if (mermaidPlaceholders.length > 0) {
            console.warn("Mermaid.render function not available or no diagrams to render. Mermaid diagrams will not be processed.");
            for (const item of mermaidPlaceholders) {
                const notice = `<div class="mermaid-render-unavailable" data-mermaid-id="${item.id}">Mermaid rendering is unavailable. Diagram code: <pre>${escape(item.code)}</pre></div>`;
                html = html.replace(item.placeholderRegex, notice);
            }
        }

        return html;
    }
}
```

### nodejs_projects/core/scripts/test-pdf-service.mjs
```javascript
import { PdfService, MarkdownService } from '../dist/esm/index.js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { JSDOM } from 'jsdom';
import * as DOMPurifyModule from 'dompurify'; // For MarkdownService

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Setup based on learnings_mermaid_dompurify_nodejs.md and bootstrap-mermaid.mjs
async function setupMarkdownServiceDependencies() {
  console.log("Setting up JSDOM, DOMPurify, and polyfills for MarkdownService...");

  const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
    pretendToBeVisual: true,
    runScripts: "dangerously",
    resources: "usable"
  });
  const window = dom.window; // JSDOM window

  // Globalize JSDOM properties
  globalThis.window = window;
  globalThis.document = window.document;
  globalThis.navigator = { userAgent: 'node.js' };

  // Explicit Globalization of DOM Types from JSDOM's window
  if (typeof window.Element !== 'undefined') globalThis.Element = window.Element;
  if (typeof window.HTMLElement !== 'undefined') globalThis.HTMLElement = window.HTMLElement;
  if (typeof window.SVGElement !== 'undefined') globalThis.SVGElement = window.SVGElement;
  if (typeof window.Node !== 'undefined') globalThis.Node = window.Node;
  if (typeof window.DocumentFragment !== 'undefined') globalThis.DocumentFragment = window.DocumentFragment;
  if (typeof window.DOMParser !== 'undefined') globalThis.DOMParser = window.DOMParser;
  if (typeof window.XMLSerializer !== 'undefined') globalThis.XMLSerializer = window.XMLSerializer;
  // Ensure other SVG types are globalized if needed by fakeBBox application
  if (typeof window.SVGGraphicsElement !== 'undefined') globalThis.SVGGraphicsElement = window.SVGGraphicsElement;
  if (typeof window.SVGSVGElement !== 'undefined') globalThis.SVGSVGElement = window.SVGSVGElement;
  if (typeof window.SVGTextElement !== 'undefined') globalThis.SVGTextElement = window.SVGTextElement;
  if (typeof window.SVGTextContentElement !== 'undefined') globalThis.SVGTextContentElement = window.SVGTextContentElement;


  // `fakeBBox` Polyfill, aligned with bootstrap-mermaid.mjs
  function fakeBBox() {
    const len = (this.textContent || '').length;
    const w = Math.max(8 * len, 40);
    const h = 16;
    return { x: 0, y: 0, width: w, height: h, top: 0, left: 0, right: w, bottom: h };
  }

  // Apply fakeBBox to JSDOM's window SVG element prototypes
  const svgElementClassesForBBox = ['SVGElement', 'SVGGraphicsElement', 'SVGSVGElement', 'SVGTextElement', 'SVGTextContentElement'];
  svgElementClassesForBBox.forEach(className => {
    if (window[className] && window[className].prototype && !window[className].prototype.getBBox) {
      window[className].prototype.getBBox = fakeBBox;
      console.log(`Applied fakeBBox to window.${className}.prototype`);
    }
  });
  // Note: SVGRectElement was not explicitly polyfilled in bootstrap-mermaid.mjs, observing if needed.

  // Unified DOMPurify Instance and Patching (consistent with bootstrap-mermaid.mjs logic)
  let actualCreateDOMPurifyFactory;
  if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    actualCreateDOMPurifyFactory = DOMPurifyModule.default;
  } else if (typeof DOMPurifyModule === 'function') { // Less common, namespace is factory
    actualCreateDOMPurifyFactory = DOMPurifyModule;
  } else {
    console.error("CRITICAL - Could not reliably identify a DOMPurify factory function.");
    actualCreateDOMPurifyFactory = DOMPurifyModule.default || DOMPurifyModule;
    if (!actualCreateDOMPurifyFactory || typeof actualCreateDOMPurifyFactory !== 'function') {
        throw new Error("Failed to resolve DOMPurify factory or it's not a function.");
    }
  }

  const DOMPurifyInstance = actualCreateDOMPurifyFactory(window); // Use JSDOM window

  const globalDOMPurifyShim = {
    sanitize: (...args) => DOMPurifyInstance.sanitize(...args),
    addHook: (...args) => DOMPurifyInstance.addHook ? DOMPurifyInstance.addHook(...args) : (() => { console.warn("DOMPurifyInstance.addHook not available"); })(),
    removeHook: (...args) => DOMPurifyInstance.removeHook ? DOMPurifyInstance.removeHook(...args) : (() => { console.warn("DOMPurifyInstance.removeHook not available"); })(),
    removeAllHooks: (...args) => DOMPurifyInstance.removeAllHooks ? DOMPurifyInstance.removeAllHooks(...args) : (() => { console.warn("DOMPurifyInstance.removeAllHooks not available"); })(),
    version: DOMPurifyModule.version || actualCreateDOMPurifyFactory.version || DOMPurifyInstance.version || 'unknown',
    isSupported: DOMPurifyModule.isSupported !== undefined ? DOMPurifyModule.isSupported : (actualCreateDOMPurifyFactory.isSupported !== undefined ? actualCreateDOMPurifyFactory.isSupported : (DOMPurifyInstance.isSupported !== undefined ? DOMPurifyInstance.isSupported : true)),
  };

  globalThis.DOMPurify = globalDOMPurifyShim;
  // window.DOMPurify = globalDOMPurifyShim; // Not strictly needed if globalThis is primary

  // Patch the imported module itself to ensure consistency if Mermaid imports 'dompurify' directly.
  if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    DOMPurifyModule.default.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    if (typeof DOMPurifyInstance.addHook === 'function') DOMPurifyModule.default.addHook = (...args) => DOMPurifyInstance.addHook(...args);
  } else if (typeof DOMPurifyModule === 'function') {
    DOMPurifyModule.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    if (typeof DOMPurifyInstance.addHook === 'function') DOMPurifyModule.addHook = (...args) => DOMPurifyInstance.addHook(...args);
  }
  console.log("DOMPurify instance created, shimmed to globalThis, and imported module patched.");

  console.log("JSDOM, DOMPurify, and polyfills for MarkdownService setup complete.");
}


async function main() {
  try {
    await setupMarkdownServiceDependencies();

    console.log('Testing PdfService with PlaywrightPdfEngine...');

    const markdownService = new MarkdownService();
    const pdfService = new PdfService(markdownService);

    const comprehensiveMarkdown = `
# Markdown Feature Test

## 1. Headings

# H1 Heading
## H2 Heading
### H3 Heading
#### H4 Heading
##### H5 Heading
###### H6 Heading

---

## 2. Emphasis

- *Italic text*
- _Italic text_
- **Bold text**
- __Bold text__
- ~~Strikethrough~~

---

## 3. Lists

### Unordered List

- Item 1
  - Subitem 1.1
    - Subitem 1.1.1
      - Subitem 1.1.1.1
        - Subitem 1.1.1.1.1
          - Subitem 1.1.1.1.1.1

### Ordered List

1. First
2. Second
   1. Sub-second
      1. Sub-sub-second

---

## 4. Links

- [Inline link](https://example.com)
- [Reference-style link][example]

[example]: https://example.com

---

## 5. Images

![Alt text for image](https://via.placeholder.com/150)

---

## 6. Code

### Inline Code

Here is some \`inline code\`.

### Code Block

\`\`\`javascript
function greet(name) {
    console.log(\`Hello, \${name}!\`);
}
\`\`\`

---

## 7. Blockquotes

> This is a blockquote.
>
> > Nested blockquote.

---

## 8. Tables

| Syntax | Description |
| ------ | ----------- |
| Header | Title       |
| Cell   | Text        |

---

## 9. Horizontal Rules

---

---

---

---

## 10. Task Lists

* [x] Task completed
* [ ] Task not completed

---

## 11. HTML Elements

<p style="color: red;">This is a paragraph with inline HTML styling.</p>

---

## 12. Escaping Characters

\\*Literal asterisks\\*

---

## 13. Mermaid Diagram

\`\`\`mermaid
graph TD
    A[Start] --> B{Is it working?}
    B -- Yes --> C[Great!]
    B -- No --> D[Fix it]
    D --> B
\`\`\`

---

## 14. Footnotes

Here is a footnote reference[^1].

[^1]: This is the footnote.

---

## 15. Definition Lists

Term 1
: Definition 1

Term 2
: Definition 2a
: Definition 2b

---

## 16. Emoji (if supported)

😄 \\:tada: :+1:

---

## 17. Math (if supported via KaTeX or MathJax)

Inline math: \\$E = mc^2\\$
Block math:

\`\`\`math
\\int_{a}^{b} x^2 dx
\`\`\`
`;

    const testHtml = `
<h1>Test HTML PDF (Playwright)</h1>
<p>This is a test directly from an HTML string using Playwright.</p>
<p>With an inline SVG:</p>
<svg width="100" height="100" id="test-svg-element">
  <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" id="test-circle-element" />
  <rect x="10" y="10" width="30" height="30" fill="blue" id="test-rect-element" />
  <image href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" x="0" y="0" height="10" width="10"/>
</svg>
<p>And some math: $$ E = mc^2 $$</p>
<p>Another paragraph.</p>`;

    console.log('\nGenerating PDF from Markdown...');
    const htmlFromMarkdown = await markdownService.parse(comprehensiveMarkdown);
    const debugHtmlPath = path.join(__dirname, 'debug_markdown_service_output.html');
    await fs.writeFile(debugHtmlPath, htmlFromMarkdown);
    console.log(`Full HTML from MarkdownService saved to ${debugHtmlPath}`);

    const markdownPdfBlob = await pdfService.generatePdfFromHtml(htmlFromMarkdown, {
      filename: 'test_markdown_playwright.pdf',
      margins: { top: 15, right: 15, bottom: 15, left: 15 },
      pageFormat: 'a4'
    });
    const markdownPdfBuffer = Buffer.from(await markdownPdfBlob.arrayBuffer());
    const markdownOutputPath = path.join(__dirname, 'test_markdown_playwright_output.pdf');
    await fs.writeFile(markdownOutputPath, markdownPdfBuffer);
    console.log(`Markdown PDF saved to ${markdownOutputPath}`);

    console.log('\nGenerating PDF from HTML...');
    const htmlPdfBlob = await pdfService.generatePdfFromHtml(testHtml, {
      filename: 'test_html_playwright.pdf',
      margins: { top: 20, right: 20, bottom: 20, left: 20 },
      pageFormat: 'letter',
      orientation: 'landscape'
    });
    const htmlPdfBuffer = Buffer.from(await htmlPdfBlob.arrayBuffer());
    const htmlOutputPath = path.join(__dirname, 'test_html_playwright_output.pdf');
    await fs.writeFile(htmlOutputPath, htmlPdfBuffer);
    console.log(`HTML PDF saved to ${htmlOutputPath}`);

    console.log('\nTest script finished successfully.');
  } catch (error) {
    console.error('Error during PdfService test (Playwright):');
    console.error('Error Name:', error.name);
    console.error('Error Message:', error.message);
    if (error.stack) {
        console.error('Error Stack:', error.stack);
    }
    if (error.cause) {
        console.error('Error Cause:', error.cause);
    }
    process.exit(1);
  }
}

main();
```

### nodejs_projects/core/scripts/debug_markdown_service_output.html
```html
<h1>Markdown Feature Test</h1>
<h2>1. Headings</h2>
<h1>H1 Heading</h1>
<h2>H2 Heading</h2>
<h3>H3 Heading</h3>
<h4>H4 Heading</h4>
<h5>H5 Heading</h5>
<h6>H6 Heading</h6>
<hr>
<h2>2. Emphasis</h2>
<ul>
<li><em>Italic text</em></li>
<li><em>Italic text</em></li>
<li><strong>Bold text</strong></li>
<li><strong>Bold text</strong></li>
<li><del>Strikethrough</del></li>
</ul>
<hr>
<h2>3. Lists</h2>
<h3>Unordered List</h3>
<ul>
<li>Item 1  <ul>
<li>Subitem 1.1  <ul>
<li>Subitem 1.1.1  <ul>
<li>Subitem 1.1.1.1  <ul>
<li>Subitem 1.1.1.1.1  <ul>
<li>Subitem 1.1.1.1.1.1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Ordered List</h3>
<ol>
<li>First</li>
<li>Second  <ol>
<li>Sub-second  <ol>
<li>Sub-sub-second</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2>4. Links</h2>
<ul>
<li><a href="https://example.com">Inline link</a></li>
<li><a href="https://example.com">Reference-style link</a></li>
</ul>
<hr>
<h2>5. Images</h2>
<p><img src="https://via.placeholder.com/150" alt="Alt text for image"></p>
<hr>
<h2>6. Code</h2>
<h3>Inline Code</h3>
<p>Here is some <code>inline code</code>.</p>
<h3>Code Block</h3>
<pre><code class="language-javascript">function greet(name) {
    console.log(`Hello, ${name}!`);
}
</code></pre>
<hr>
<h2>7. Blockquotes</h2>
<blockquote>
<p>This is a blockquote.</p>
<blockquote>
<p>Nested blockquote.</p>
</blockquote>
</blockquote>
<hr>
<h2>8. Tables</h2>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Cell</td>
<td>Text</td>
</tr>
</tbody></table>
<hr>
<h2>9. Horizontal Rules</h2>
<hr>
<hr>
<hr>
<hr>
<h2>10. Task Lists</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> Task completed</li>
<li><input disabled="" type="checkbox"> Task not completed</li>
</ul>
<hr>
<h2>11. HTML Elements</h2>
<p style="color: red;">This is a paragraph with inline HTML styling.</p>

<hr>
<h2>12. Escaping Characters</h2>
<p>*Literal asterisks*</p>
<hr>
<h2>13. Mermaid Diagram</h2>
<div class="mermaid"><svg id="mermaid-svg-1747772135087-w7aae4wd6xn" width="100%" xmlns="http://www.w3.org/2000/svg" class="flowchart" style="max-width: 40720px;" viewBox="-8 -8 40720 32" role="graphics-document document" aria-roledescription="flowchart-v2"><style>#mermaid-svg-1747772135087-w7aae4wd6xn{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}@keyframes edge-animation-frame{from{stroke-dashoffset:0;}}@keyframes dash{to{stroke-dashoffset:0;}}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-animation-slow{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 50s linear infinite;stroke-linecap:round;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-animation-fast{stroke-dasharray:9,5!important;stroke-dashoffset:900;animation:dash 20s linear infinite;stroke-linecap:round;}#mermaid-svg-1747772135087-w7aae4wd6xn .error-icon{fill:#552222;}#mermaid-svg-1747772135087-w7aae4wd6xn .error-text{fill:#552222;stroke:#552222;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-thickness-normal{stroke-width:1px;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-thickness-thick{stroke-width:3.5px;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-pattern-solid{stroke-dasharray:0;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-thickness-invisible{stroke-width:0;fill:none;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-svg-1747772135087-w7aae4wd6xn .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-svg-1747772135087-w7aae4wd6xn .marker{fill:#333333;stroke:#333333;}#mermaid-svg-1747772135087-w7aae4wd6xn .marker.cross{stroke:#333333;}#mermaid-svg-1747772135087-w7aae4wd6xn svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-svg-1747772135087-w7aae4wd6xn p{margin:0;}#mermaid-svg-1747772135087-w7aae4wd6xn .label{font-family:"trebuchet ms",verdana,arial,sans-serif;color:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster-label text{fill:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster-label span{color:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster-label span p{background-color:transparent;}#mermaid-svg-1747772135087-w7aae4wd6xn .label text,#mermaid-svg-1747772135087-w7aae4wd6xn span{fill:#333;color:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn .node rect,#mermaid-svg-1747772135087-w7aae4wd6xn .node circle,#mermaid-svg-1747772135087-w7aae4wd6xn .node ellipse,#mermaid-svg-1747772135087-w7aae4wd6xn .node polygon,#mermaid-svg-1747772135087-w7aae4wd6xn .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid-svg-1747772135087-w7aae4wd6xn .rough-node .label text,#mermaid-svg-1747772135087-w7aae4wd6xn .node .label text,#mermaid-svg-1747772135087-w7aae4wd6xn .image-shape .label,#mermaid-svg-1747772135087-w7aae4wd6xn .icon-shape .label{text-anchor:middle;}#mermaid-svg-1747772135087-w7aae4wd6xn .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-svg-1747772135087-w7aae4wd6xn .rough-node .label,#mermaid-svg-1747772135087-w7aae4wd6xn .node .label,#mermaid-svg-1747772135087-w7aae4wd6xn .image-shape .label,#mermaid-svg-1747772135087-w7aae4wd6xn .icon-shape .label{text-align:center;}#mermaid-svg-1747772135087-w7aae4wd6xn .node.clickable{cursor:pointer;}#mermaid-svg-1747772135087-w7aae4wd6xn .root .anchor path{fill:#333333!important;stroke-width:0;stroke:#333333;}#mermaid-svg-1747772135087-w7aae4wd6xn .arrowheadPath{fill:#333333;}#mermaid-svg-1747772135087-w7aae4wd6xn .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid-svg-1747772135087-w7aae4wd6xn .flowchart-link{stroke:#333333;fill:none;}#mermaid-svg-1747772135087-w7aae4wd6xn .edgeLabel{background-color:rgba(232,232,232, 0.8);text-align:center;}#mermaid-svg-1747772135087-w7aae4wd6xn .edgeLabel p{background-color:rgba(232,232,232, 0.8);}#mermaid-svg-1747772135087-w7aae4wd6xn .edgeLabel rect{opacity:0.5;background-color:rgba(232,232,232, 0.8);fill:rgba(232,232,232, 0.8);}#mermaid-svg-1747772135087-w7aae4wd6xn .labelBkg{background-color:rgba(232, 232, 232, 0.5);}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster text{fill:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn .cluster span{color:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid-svg-1747772135087-w7aae4wd6xn .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#333;}#mermaid-svg-1747772135087-w7aae4wd6xn rect.text{fill:none;stroke-width:0;}#mermaid-svg-1747772135087-w7aae4wd6xn .icon-shape,#mermaid-svg-1747772135087-w7aae4wd6xn .image-shape{background-color:rgba(232,232,232, 0.8);text-align:center;}#mermaid-svg-1747772135087-w7aae4wd6xn .icon-shape p,#mermaid-svg-1747772135087-w7aae4wd6xn .image-shape p{background-color:rgba(232,232,232, 0.8);padding:2px;}#mermaid-svg-1747772135087-w7aae4wd6xn .icon-shape rect,#mermaid-svg-1747772135087-w7aae4wd6xn .image-shape rect{opacity:0.5;background-color:rgba(232,232,232, 0.8);fill:rgba(232,232,232, 0.8);}#mermaid-svg-1747772135087-w7aae4wd6xn :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}</style><g><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointEnd" class="marker flowchart-v2" viewBox="0 0 10 10" refX="5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1,0;"></path></marker><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointStart" class="marker flowchart-v2" viewBox="0 0 10 10" refX="4.5" refY="5" markerUnits="userSpaceOnUse" markerWidth="8" markerHeight="8" orient="auto"><path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1,0;"></path></marker><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-circleEnd" class="marker flowchart-v2" viewBox="0 0 10 10" refX="11" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1,0;"></circle></marker><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-circleStart" class="marker flowchart-v2" viewBox="0 0 10 10" refX="-1" refY="5" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><circle cx="5" cy="5" r="5" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1,0;"></circle></marker><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-crossEnd" class="marker cross flowchart-v2" viewBox="0 0 11 11" refX="12" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1,0;"></path></marker><marker id="mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-crossStart" class="marker cross flowchart-v2" viewBox="0 0 11 11" refX="-1" refY="5.2" markerUnits="userSpaceOnUse" markerWidth="11" markerHeight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1,0;"></path></marker><g class="root"><g class="clusters"></g><g class="edgePaths"><path d="M83,24L83,28.167C83,32.333,83,40.667,83.072,49.25C83.145,57.834,83.29,66.667,83.362,71.084L83.434,75.501" id="L_A_B_0" class=" edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style="" marker-end="url(#mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointEnd)"></path><path d="M66.625,92.625L60.188,96.354C53.75,100.083,40.875,107.542,34.438,114.771C28,122,28,129,28,132.5L28,136" id="L_B_C_0" class=" edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style="" marker-end="url(#mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointEnd)"></path><path d="M83.5,99.5L83.417,102.083C83.333,104.667,83.167,109.833,87.017,116.126C90.868,122.419,98.737,129.837,102.671,133.547L106.605,137.256" id="L_B_D_0" class=" edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style="" marker-end="url(#mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointEnd)"></path><path d="M120.424,140L121.687,135.833C122.949,131.667,125.475,123.333,121.494,115.342C117.513,107.35,107.026,99.7,101.783,95.875L96.539,92.05" id="L_D_B_0" class=" edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style="" marker-end="url(#mermaid-svg-1747772135087-w7aae4wd6xn_flowchart-v2-pointEnd)"></path></g><g class="edgeLabels"><g class="edgeLabel"><g class="label" transform="translate(0, 0)"><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml" class="labelBkg"><span class="edgeLabel "></span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(undefined, NaN)"><g class="label" transform="translate(0, 0)"><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml" class="labelBkg"><span class="edgeLabel "><p>Yes</p></span></div></foreignObject></g></g><g class="edgeLabel" transform="translate(undefined, NaN)"><g class="label" transform="translate(0, 0)"><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml" class="labelBkg"><span class="edgeLabel "><p>No</p></span></div></foreignObject></g></g><g class="edgeLabel"><g class="label" transform="translate(0, 0)"><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml" class="labelBkg"><span class="edgeLabel "></span></div></foreignObject></g></g></g><g class="nodes"><g class="node default  " id="flowchart-A-0" transform="translate(83, 16)"><rect class="basic label-container" style="" x="-30" y="-15" width="60" height="30"></rect><g class="label" style="" transform="translate(0, 0)"><rect></rect><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel "><p>Start</p></span></div></foreignObject></g></g><g class="node default  " id="flowchart-B-1" transform="translate(83, 82)"><polygon points="15,0 30,-15 15,-30 0,-15" class="label-container" transform="translate(-15,15)"></polygon><g class="label" style="" transform="translate(0, 0)"><rect></rect><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel "><p>Is it working?</p></span></div></foreignObject></g></g><g class="node default  " id="flowchart-C-3" transform="translate(28, 148)"><rect class="basic label-container" style="" x="-30" y="-15" width="60" height="30"></rect><g class="label" style="" transform="translate(0, 0)"><rect></rect><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel "><p>Great!</p></span></div></foreignObject></g></g><g class="node default  " id="flowchart-D-5" transform="translate(118, 148)"><rect class="basic label-container" style="" x="-30" y="-15" width="60" height="30"></rect><g class="label" style="" transform="translate(0, 0)"><rect></rect><foreignObject width="0" height="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel "><p>Fix it</p></span></div></foreignObject></g></g></g></g></g></svg></div><hr>
<h2>14. Footnotes</h2>
<p>Here is a footnote reference[^1].</p>
<p>[^1]: This is the footnote.</p>
<hr>
<h2>15. Definition Lists</h2>
<p>Term 1<br>: Definition 1</p>
<p>Term 2<br>: Definition 2a<br>: Definition 2b</p>
<hr>
<h2>16. Emoji (if supported)</h2>
<p>😄 :tada: :+1:</p>
<hr>
<h2>17. Math (if supported via KaTeX or MathJax)</h2>
<p>Inline math: $E = mc^2$<br>Block math:</p>
<pre><code class="language-math">\int_{a}^{b} x^2 dx
</code></pre>
```

### nodejs_projects/core/scripts/bootstrap-mermaid.mjs
```javascript
// nodejs_projects/core/scripts/bootstrap-mermaid.mjs
import { JSDOM } from 'jsdom';
// const rawDompurifyImport = require('dompurify'); // TRY THIS!
import mermaid from 'mermaid';

// If using require:
// import { createRequire } from 'module';
// const require = createRequire(import.meta.url);
// const rawDompurifyImport = require('dompurify');

// Let's stick to ESM import for now, but be very specific:
import * as DOMPurifyModule from 'dompurify';

let actualCreateDOMPurifyFactory;

console.log("--- DOMPurify Import Inspection ---");
console.log("Bootstrap: DOMPurifyModule (from 'import * as DOMPurifyModule from 'dompurify'):", DOMPurifyModule);

// The default export is usually the factory function.
// Static methods might be on the namespace import (DOMPurifyModule) itself or on its default.
if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    console.log("Bootstrap: DOMPurifyModule.default is a function.");
    // Check if statics are on the default export
    if (typeof DOMPurifyModule.default.addHook === 'function') {
        actualCreateDOMPurifyFactory = DOMPurifyModule.default;
        console.log("Bootstrap: Identified factory and statics on DOMPurifyModule.default.");
    }
    // Check if statics are on the namespace import and default is the factory
    else if (typeof DOMPurifyModule.addHook === 'function') {
        actualCreateDOMPurifyFactory = DOMPurifyModule.default; // Factory
        // In this case, we'll need to use DOMPurifyModule.addHook later
        console.log("Bootstrap: Identified factory on DOMPurifyModule.default, statics might be on DOMPurifyModule itself.");
    } else {
        actualCreateDOMPurifyFactory = DOMPurifyModule.default; // Assume it's the factory
        console.warn("Bootstrap: DOMPurifyModule.default is function, but addHook not found on it or on the namespace. Will proceed with patching sanitize.");
    }
} else if (typeof DOMPurifyModule.addHook === 'function' && typeof DOMPurifyModule === 'function') {
    // Less common: namespace import itself is the factory and has statics
    actualCreateDOMPurifyFactory = DOMPurifyModule;
    console.log("Bootstrap: Identified factory and statics on DOMPurifyModule (namespace import itself).");
} else {
    console.error("Bootstrap: CRITICAL - Could not identify a DOMPurify factory function with addHook from 'import * as DOMPurifyModule'.");
    console.error("Bootstrap:   DOMPurifyModule.default:", DOMPurifyModule.default);
    console.error("Bootstrap:   typeof DOMPurifyModule.addHook:", typeof DOMPurifyModule.addHook);
    actualCreateDOMPurifyFactory = DOMPurifyModule.default || DOMPurifyModule; // Best guess
    if (!actualCreateDOMPurifyFactory) {
      throw new Error("Failed to resolve DOMPurify factory from namespace import.");
    }
}

console.log("Bootstrap: Tentatively using as factory:", actualCreateDOMPurifyFactory);
console.log("Bootstrap:   typeof actualCreateDOMPurifyFactory:", typeof actualCreateDOMPurifyFactory);
console.log("Bootstrap:   (For statics) typeof DOMPurifyModule.addHook:", typeof DOMPurifyModule.addHook);
console.log("Bootstrap:   (For statics) typeof actualCreateDOMPurifyFactory.addHook:", typeof actualCreateDOMPurifyFactory.addHook);
console.log("--- End DOMPurify Import Inspection ---");


// 1. Fake a browser environment with JSDOM
const { window } = new JSDOM('');
globalThis.window = window;
globalThis.document = window.document;
globalThis.navigator = { userAgent: 'node.js' };
// ... (rest of JSDOM setup and polyfills) ...
if (typeof window.Element !== 'undefined') globalThis.Element = window.Element;
if (typeof window.HTMLElement !== 'undefined') globalThis.HTMLElement = window.HTMLElement;
if (typeof window.SVGElement !== 'undefined') globalThis.SVGElement = window.SVGElement;
if (typeof window.Node !== 'undefined') globalThis.Node = window.Node;
if (typeof window.DocumentFragment !== 'undefined') globalThis.DocumentFragment = window.DocumentFragment;
console.log("Bootstrap: JSDOM window, document, navigator, and essential DOM types globalized.");

function fakeBBox() {
  const len = (this.textContent || '').length;
  const w = Math.max(8 * len, 40);
  const h = 16;
  return { x: 0, y: 0, width: w, height: h, top: 0, left: 0, right: w, bottom: h };
}
const svgElementClasses = ['SVGElement', 'SVGGraphicsElement', 'SVGSVGElement', 'SVGTextElement', 'SVGTextContentElement'];
svgElementClasses.forEach(name => {
  if (window[name] && window[name].prototype && !window[name].prototype.getBBox) {
    window[name].prototype.getBBox = fakeBBox;
  }
});
console.log("Bootstrap: fakeBBox polyfill applied where needed on SVG element prototypes.");


// 2. Create a DOMPurify INSTANCE using the identified factory and the JSDOM window
if (typeof actualCreateDOMPurifyFactory !== 'function') {
    console.error("Bootstrap: CRITICAL - The resolved 'actualCreateDOMPurifyFactory' is not a function. Cannot create DOMPurify instance. Value:", actualCreateDOMPurifyFactory);
    throw new Error("DOMPurify factory resolution failed; it's not a function.");
}
const DOMPurifyInstance = actualCreateDOMPurifyFactory(window);

// Patch only the factory (writable) – skip DOMPurifyModule ------------
['addHook', 'removeHook', 'removeAllHooks'].forEach((m) => {
  actualCreateDOMPurifyFactory[m] = (...a) => DOMPurifyInstance[m](...a);
});

// 3. Build the global shim
const GlobalDOMPurifyObject = {
  sanitize: (...args) => DOMPurifyInstance.sanitize(...args),
  version: DOMPurifyModule.version ?? actualCreateDOMPurifyFactory.version ?? 'unknown',
  isSupported:
    DOMPurifyModule.isSupported ??
    actualCreateDOMPurifyFactory.isSupported ??
    false,
};

// Now add the delegates for Mermaid’s hooks ---------------------------
['addHook', 'removeHook', 'removeAllHooks'].forEach(
  (m) => (GlobalDOMPurifyObject[m] = (...a) => DOMPurifyInstance[m](...a))
);

globalThis.DOMPurify = GlobalDOMPurifyObject;
console.log("Bootstrap: globalThis.DOMPurify set up with instance .sanitize and best-effort static methods.");

// Verification
if (typeof globalThis.DOMPurify !== 'undefined' &&
    typeof globalThis.DOMPurify.sanitize === 'function' &&
    typeof globalThis.DOMPurify.addHook === 'function') {
    console.log("Bootstrap: globalThis.DOMPurify.sanitize and .addHook are functions.");
    if (globalThis.DOMPurify.addHook.name === 'missingAddHook') {
        console.warn("Bootstrap: globalThis.DOMPurify.addHook is a STUB function. Mermaid might not behave as expected if it relies on real hook functionality.");
    }
} else {
    let errors = [];
    if (typeof globalThis.DOMPurify === 'undefined') errors.push("globalThis.DOMPurify is undefined");
    else {
        if (typeof globalThis.DOMPurify.sanitize !== 'function') errors.push("globalThis.DOMPurify.sanitize is NOT a function");
        if (typeof globalThis.DOMPurify.addHook !== 'function') errors.push(`globalThis.DOMPurify.addHook is NOT a function (it is ${typeof globalThis.DOMPurify.addHook})`);
    }
    console.error(`Bootstrap: ERROR - globalThis.DOMPurify is not correctly configured. Issues: ${errors.join(', ')}.`);
}


// 4. Patch the imported module itself if it's different from our global,
//    to ensure consistency if Mermaid imports 'dompurify' directly.
//    This is tricky because 'DOMPurifyModule' is a namespace.
//    If 'DOMPurifyModule.default' is the factory, we patch that.
if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    DOMPurifyModule.default.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    // If static methods were on the module and not default, ensure they are still accessible
    if(!DOMPurifyModule.default.addHook && DOMPurifyModule.addHook) DOMPurifyModule.default.addHook = DOMPurifyModule.addHook;
    // ... and other statics
    console.log("Bootstrap: Patched DOMPurifyModule.default.sanitize. Ensured addHook if available on module.");
} else if (typeof DOMPurifyModule === 'function') { // If the namespace itself was the factory
    DOMPurifyModule.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    console.log("Bootstrap: Patched DOMPurifyModule.sanitize (assuming namespace is factory).");
}


// 5. Configure Mermaid
mermaid.initialize({
  startOnLoad: false,
  securityLevel: 'strict',
  theme: 'default',
  flowchart: { htmlLabels: false },
  dompurifyConfig: {
    USE_PROFILES: { html: true, svg: true, svgFilters: true },
    ADD_TAGS: ['foreignObject'],
    ADD_ATTR: ['dominant-baseline', 'style', 'id', 'class', 'width', 'height', 'x', 'y', 'cx', 'cy', 'r', 'd', 'fill', 'stroke', 'stroke-width', 'transform', 'viewBox', 'preserveAspectRatio', 'marker-end', 'marker-start', 'filter', 'href', 'xlink:href', 'tabindex'],
  }
});
console.log("Bootstrap: Mermaid initialized.");

export { mermaid, GlobalDOMPurifyObject as DOMPurify };

console.log("Bootstrap: End of script. Type of globalThis.DOMPurify.addHook:", typeof globalThis.DOMPurify.addHook);
if (globalThis.DOMPurify.addHook) console.log("Bootstrap: End of script. globalThis.DOMPurify.addHook.name:", globalThis.DOMPurify.addHook.name);