# Mermaid Diagram Rendering Issues in JSDOM and Playwright PDF Output

## Problem Statement

Mermaid diagrams rendered in a JSDOM environment for subsequent PDF generation via Playwright exhibit multiple issues:
1.  The HTML output (`debug_markdown_service_output.html`) shows blank areas or malformed SVGs for Mermaid diagrams when viewed in a browser, indicating a failure in the initial JSDOM rendering phase.
2.  The generated PDF, while attempting to display the diagrams, shows them as very small, missing text within nodes, and with incorrect layering where node boxes overlap arrowheads.
These issues persist despite configuring Mermaid for `htmlLabels: false` (to use SVG text elements) and applying polyfills for `getBBox` and `getComputedTextLength` in the JSDOM environment.

## Table of Contents

* [Background](#background)
* [Attempted Fixes](#attempted-fixes)
* [Hypothesis](#hypothesis)
* [Prior Research](#prior-research)
  * [documentation/03_Implementation/issue_research_20250521_mermaid-diagram-issue_take9_pivot_o3.md](#documentation03_implementationissue_research_20250521_mermaid-diagram-issue_take9_pivot_o3md)
  * [documentation/03_Implementation/problem_statement-MermaidGetComputedTextLengthJSDOMPolyfill_20250521.md](#documentation03_implementationproblem_statement-mermaidgetcomputedtextlengthjsdompolyfill_20250521md)
* [Dependencies](#dependencies)
  * [nodejs_projects/core/src/services/markdown/markdown.service.ts](#nodejs_projectscoreservicesmarkdownmarkdownservicets)
  * [nodejs_projects/core/scripts/test-pdf-service.mjs](#nodejs_projectscorescriptstest-pdf-servicemjs)
  * [nodejs_projects/core/src/services/pdf/playwright.engine.ts](#nodejs_projectscoreservicespdfplaywrightenginets)
  * [nodejs_projects/core/src/services/pdf/playwright-dom-correction.js](#nodejs_projectscoreservicespdfplaywright-dom-correctionjs)

## Background

The project aims to convert Markdown, including complex Mermaid diagrams, into PDFs. Initially, issues with `foreignObject` elements in Mermaid SVGs (often rendered with zero dimensions) led to problems in Playwright PDF generation. To address this, Mermaid was configured with `htmlLabels: false` to force the use of pure SVG `<text>` elements. This, however, introduced a new problem: JSDOM's lack of a proper `getComputedTextLength` implementation, which Mermaid relies on for text-only rendering, causing `TypeError`s.

Polyfills for `getBBox` and `getComputedTextLength` were introduced in the `test-pdf-service.mjs` script to support JSDOM. A refined `fakeBBox` polyfill was added to handle cases where an SVG element's `textContent` might inadvertently include large CSS blocks, preventing massively oversized initial bounding box calculations.

Despite these polyfills, the `debug_markdown_service_output.html` (generated by `MarkdownService` in JSDOM) fails to render Mermaid diagrams correctly when viewed in a browser (showing blank or malformed SVGs). Subsequently, the PDF generated by Playwright from this HTML, while showing some diagram structure (likely due to `playwright-dom-correction.js` adjusting the `viewBox`), suffers from missing text and incorrect arrow/node layering.

## Attempted Fixes

1.  **`htmlLabels: false` Configuration**: Mermaid was configured in `MarkdownService` to use `htmlLabels: false` for flowcharts, sequences, and state diagrams to avoid `<foreignObject>` issues.
2.  **`getBBox` Polyfill**: A `fakeBBox` function was implemented and applied to SVG element prototypes in JSDOM to provide estimated bounding boxes.
3.  **`getComputedTextLength` Polyfill**: A `fakeGetComputedTextLength` function was implemented and applied to SVG text-related element prototypes in JSDOM to provide estimated text lengths. This was applied more robustly by fetching prototypes from created elements.
4.  **Refined `fakeBBox` for CSS in `textContent`**: The `fakeBBox` polyfill was updated to detect if `textContent` contained CSS and, if so, to calculate a minimal bounding box to prevent extremely large initial SVG dimensions. This successfully corrected the initial `viewBox` size reported by `playwright-dom-correction.js`.
5.  **`playwright-dom-correction.js` Script**: This script, executed in Playwright's browser context, attempts to correct SVG issues, primarily by recalculating the `viewBox` based on `getBBox()` in the browser and fixing `NaN` transforms. It currently skips `<foreignObject>` corrections due to the `htmlLabels: false` strategy.

## Hypothesis

The core issue lies in the SVG generated by Mermaid within the JSDOM environment. Despite the polyfills, this SVG is likely malformed or incomplete, leading to blank/broken rendering in the `debug_markdown_service_output.html`. The polyfills for `getComputedTextLength` and `getBBox` might be preventing outright crashes in JSDOM but are not sufficient for Mermaid to correctly calculate layout and render a valid SVG structure.

When Playwright processes this malformed SVG:
*   The `playwright-dom-correction.js` script, by re-evaluating `getBBox()` in a full browser environment and adjusting the `viewBox`, manages to make *something* visible.
*   However, because the underlying SVG structure from JSDOM is flawed (e.g., text elements might be missing, misplaced, or have zero effective size due to incorrect JSDOM measurements), the final PDF exhibits missing text.
*   The arrowheads being overlapped by boxes suggest issues with SVG element ordering or incorrect path/marker rendering stemming from the initial malformed SVG.

The `fakeBBox for foreignObject...` logs observed during JSDOM processing are anomalous if `htmlLabels: false` is truly effective, suggesting a potential issue with the Mermaid configuration application or a misunderstanding of which elements are being measured by `fakeBBox`.

Further research should focus on:
1.  Verifying the exact SVG output from `mermaid.render()` within `MarkdownService` to inspect its structure directly after JSDOM processing.
2.  Investigating if the `htmlLabels: false` configuration is consistently applied and respected by Mermaid in the JSDOM context.
3.  Potentially enhancing the JSDOM polyfills or exploring alternative strategies for SVG generation if JSDOM proves too limited for accurate Mermaid rendering even with `htmlLabels: false`.
## Prior Research

### documentation/03_Implementation/issue_research_20250521_mermaid-diagram-issue_take9_pivot_o3.md
```markdown
Okay, this is a classic JSDOM limitation when dealing with SVG text measurements. JSDOM doesn't perform actual rendering, so methods that rely on layout and rendering, like `getComputedTextLength()`, are often not implemented or return placeholder values.

Here's a breakdown of the issue and how to address it:

**The Core Problem: `getComputedTextLength` in JSDOM**

Mermaid, when `htmlLabels: false`, relies on `getComputedTextLength()` to measure the width of SVG `<text>` and `<tspan>` elements to correctly position and wrap text. JSDOM, being a virtual DOM, doesn't have a rendering engine to accurately compute these values. While it might provide a stub for the function on the prototypes, this stub often returns 0 or throws an error, leading to the `TypeError` you're seeing.

Your polyfill attempts were on the right track but faced two main hurdles:

1.  **Accessing JSDOM Prototypes:** Accessing JSDOM's internal prototypes for SVG elements using `window[className]` can be unreliable. JSDOM might not expose all SVG element constructors directly on the `window` object in the same way a browser does, or its prototype chain might be structured differently.
2.  **JSDOM's Own Stubs:** JSDOM might already have a basic, non-functional `getComputedTextLength` on these prototypes. If your polyfill checks for existence (`!window[className].prototype.getComputedTextLength`), it might not apply itself. Forcing an overwrite is necessary, but only if you can reliably get the prototype.

**Solution: Robust Polyfill Application**

The hypothesis is correct: a more robust method of accessing the SVG element prototypes is needed. You can achieve this by creating an element and then getting its prototype.

Here's how you can modify your `test-pdf-service.mjs` to more reliably polyfill `getComputedTextLength`:

```javascript
// In test-pdf-service.mjs

// ... (other setup code)

async function setupMarkdownServiceDependencies() {
  console.log("Setting up JSDOM, DOMPurify, and polyfills for MarkdownService...");
  
  const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
    pretendToBeVisual: true,
    runScripts: "dangerously",
    resources: "usable"
  });
  const window = dom.window;
  const document = window.document; // Use this for creating elements
  
  // Globalize JSDOM properties
  globalThis.window = window;
  globalThis.document = window.document;
  globalThis.navigator = { userAgent: 'node.js' };

  // Explicit Globalization of DOM Types (keep this as is)
  // ...

  // `fakeBBox` Polyfill (keep this as is or refine as needed)
  function fakeBBox() {
    const len = (this.textContent || '').length;
    // More realistic estimates, considering average character width and some padding
    const estimatedCharWidth = 8; // Average width of a character in pixels
    const padding = 10; // Some padding
    const w = Math.max(estimatedCharWidth * len + padding, 40); 
    const h = Math.max(18, 18); // Approximate line height
    return { x: 0, y: 0, width: w, height: h, top: 0, left: 0, right: w, bottom: h };
  }

  // Apply fakeBBox to JSDOM's window SVG element prototypes
  // This approach is generally okay, but can also be improved if needed
  const svgElementClassesForBBox = ['SVGElement', 'SVGGraphicsElement', 'SVGSVGElement', 'SVGTextElement', 'SVGTextContentElement', 'SVGTSpanElement'];
  svgElementClassesForBBox.forEach(className => {
    if (window[className] && window[className].prototype && !window[className].prototype.getBBox) {
      window[className].prototype.getBBox = fakeBBox;
      console.log(`Applied fakeBBox to window.${className}.prototype`);
    } else if (window[className] && window[className].prototype && window[className].prototype.getBBox && window[className].prototype.getBBox !== fakeBBox) {
      // console.log(`window.${className}.prototype.getBBox already exists. Overwriting with fakeBBox.`);
      // window[className].prototype.getBBox = fakeBBox; // Uncomment to force overwrite if JSDOM's version is problematic
    }
  });


  // `getComputedTextLength` Polyfill
  function fakeGetComputedTextLength() {
    const text = this.textContent || '';
    const charCount = text.length;
    // This is a very rough estimate. More sophisticated calculation might involve
    // an average character width based on the font-family and font-size if known,
    // but JSDOM doesn't compute styles in a way that makes this easy.
    // For Mermaid, a consistent, non-zero value is often enough to avoid errors.
    const estimatedCharWidth = 8; // pixels per character (adjust as needed)
    const computedLength = charCount * estimatedCharWidth;
    // console.log(`fakeGetComputedTextLength for "${text}": ${computedLength}`);
    return computedLength;
  }

  // More robustly apply getComputedTextLength to relevant SVG element prototypes
  console.log("Attempting to polyfill getComputedTextLength...");

  try {
    const svgTextElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    const svgTSpanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');

    const textElementProto = Object.getPrototypeOf(svgTextElement);
    const tspanElementProto = Object.getPrototypeOf(svgTSpanElement);
    // SVGTextContentElement is an interface implemented by SVGTextElement and SVGTSpanElement.
    // Polyfilling the concrete types is usually sufficient.
    // If SVGTextContentElement itself needs polyfilling directly:
    // const textContentElementProto = Object.getPrototypeOf(textElementProto); // Or Object.getPrototypeOf(tspanElementProto)

    if (textElementProto && typeof textElementProto.getComputedTextLength !== 'function') {
      textElementProto.getComputedTextLength = fakeGetComputedTextLength;
      console.log("Polyfilled getComputedTextLength on SVGTextElement prototype.");
    } else if (textElementProto && textElementProto.getComputedTextLength !== fakeGetComputedTextLength) {
      console.log("Overwriting existing getComputedTextLength on SVGTextElement prototype.");
      textElementProto.getComputedTextLength = fakeGetComputedTextLength;
    } else if (textElementProto) {
      console.log("getComputedTextLength already exists and matches polyfill on SVGTextElement prototype (or was already polyfilled).");
    } else {
      console.warn("Could not get SVGTextElement prototype to polyfill getComputedTextLength.");
    }

    if (tspanElementProto && typeof tspanElementProto.getComputedTextLength !== 'function') {
      tspanElementProto.getComputedTextLength = fakeGetComputedTextLength;
      console.log("Polyfilled getComputedTextLength on SVGTSpanElement prototype.");
    } else if (tspanElementProto && tspanElementProto.getComputedTextLength !== fakeGetComputedTextLength) {
      console.log("Overwriting existing getComputedTextLength on SVGTSpanElement prototype.");
      tspanElementProto.getComputedTextLength = fakeGetComputedTextLength;
    } else if (tspanElementProto) {
      console.log("getComputedTextLength already exists and matches polyfill on SVGTSpanElement prototype (or was already polyfilled).");
    } else {
      console.warn("Could not get SVGTSpanElement prototype to polyfill getComputedTextLength.");
    }

    // Check if SVGTextContentElement is a direct part of the proto chain and if it has the method.
    // This is less common to need to polyfill directly if the concrete types are handled.
    // However, if Mermaid specifically checks `instanceof SVGTextContentElement` and calls the method,
    // and if JSDOM has a separate prototype for it in the chain, you might need this.
    // For now, targeting SVGTextElement and SVGTSpanElement directly is usually the most effective.

  } catch (e) {
    console.error("Error during getComputedTextLength polyfill application:", e);
  }

  // ... (DOMPurify setup, etc.)
  
  console.log("JSDOM, DOMPurify, and polyfills for MarkdownService setup complete.");
}

// ... (main function)
```

**Explanation of Changes in `setupMarkdownServiceDependencies`:**

1.  **Get Prototypes via `document.createElementNS`**:
    *   `document.createElementNS('http://www.w3.org/2000/svg', 'text')` creates an actual SVG text element within the JSDOM environment.
    *   `Object.getPrototypeOf()` on this element reliably gives you the prototype object that JSDOM uses for `SVGTextElement` instances.
    *   The same is done for `SVGTSpanElement`.

2.  **Unconditional Polyfill (Overwrite):**
    *   The code now checks if `getComputedTextLength` is not the `fakeGetComputedTextLength` function itself before overwriting. This is a more robust way to ensure your polyfill is applied if a different (potentially non-functional JSDOM-native) version exists.
    *   The `console.log` statements will help you see what's happening (whether it's newly applying or overwriting).

3.  **`fakeGetComputedTextLength` Logic:**
    *   The provided `fakeGetComputedTextLength` is a common approach: multiply character count by an estimated average character width. `8` is a starting point; you might need to tweak this if Mermaid's layout seems significantly off, but often, just having *a reasonable non-zero number* is enough to prevent errors and allow Mermaid to proceed.
    *   Mermaid uses this for internal calculations. As long as it's somewhat proportional to the text length, it can often work well enough for JSDOM-based rendering where perfect visual accuracy isn't the primary goal (compared to actual browser rendering).

4.  **`fakeBBox` Refinement (Optional but Recommended):**
    *   I've included a slightly more refined `fakeBBox` which attempts to provide somewhat more realistic dimensions. This can also help Mermaid's layout engine.

**Regarding `SVGTextContentElement`:**

`SVGTextContentElement` is an interface in the SVG specification that `SVGTextElement` and `SVGTSpanElement` (and others like `SVGTextPathElement`) implement. It defines common properties and methods for elements that contain text.

In JSDOM (and browsers), the methods defined by `SVGTextContentElement` (like `getComputedTextLength`) are typically implemented on the prototypes of the concrete elements (`SVGTextElement.prototype`, `SVGTSpanElement.prototype`). So, by polyfilling these concrete prototypes, you are effectively covering the `getComputedTextLength` requirement. It's less common to need to (or be able to directly) polyfill `SVGTextContentElement.prototype` itself in JSDOM, as it might not exist as a distinct object in the JavaScript prototype chain in the same way a concrete element's prototype does.

**Further Considerations:**

*   **Mermaid Version:** Ensure your Mermaid version (`mermaid` package) is up-to-date. Newer versions might have improved handling or different internal logic for text measurement, though the reliance on `getComputedTextLength` for `htmlLabels: false` is fundamental.
*   **DOMPurify and Security:** Your `MarkdownService` and `test-pdf-service.mjs` correctly initialize DOMPurify. This is crucial when dealing with SVG output, especially if any part of the text content could be user-supplied.
*   **Error Logging:** The `console.error` in your `mermaid.render` catch block in `MarkdownService` is good for debugging diagram-specific rendering issues.

By applying the polyfill directly to the prototypes obtained from actual JSDOM-created SVG elements, you should be able to resolve the `TypeError` and allow Mermaid to complete its rendering process in the JSDOM environment.
### documentation/03_Implementation/problem_statement-MermaidGetComputedTextLengthJSDOMPolyfill_20250521.md
```markdown
# Mermaid `getComputedTextLength` Polyfill Issues in JSDOM for Text-Only Rendering

## Problem Statement

When rendering Mermaid diagrams with `htmlLabels: false` (for text-only SVG output) within a Node.js environment using JSDOM, Mermaid's internal text measurement function `computeWidthOfText` fails with the error `TypeError: testSpan.node(...).getComputedTextLength is not a function`. This occurs because the JSDOM environment, even with existing polyfills for `getBBox`, does not provide a fully functional `getComputedTextLength` method on SVG text-related elements (`SVGTextContentElement`, `SVGTSpanElement`, `SVGTextElement`) that Mermaid expects for pure SVG text measurement.

## Table of Contents

* [Background](#background)
* [Attempted Fixes](#attempted-fixes)
* [Hypothesis](#hypothesis)
* [Prior Research](#prior-research)
  * [documentation/03_Implementation/issue_research_20250521_mermaid-diagram-issue_take8_pivot_o3_mermaid_text_only.md](#documentation03_implementationissue_research_20250521_mermaid-diagram-issue_take8_pivot_o3_mermaid_text_onlymd)
* [Dependencies](#dependencies)
  * [nodejs_projects/core/src/services/markdown/markdown.service.ts](#nodejs_projectscoreservicesmarkdownmarkdownservicets)
  * [nodejs_projects/core/scripts/test-pdf-service.mjs](#nodejs_projectscorescriptstest-pdf-servicemjs)

## Background

The project aims to generate PDFs from Markdown content, including Mermaid diagrams. To improve PDF compatibility and avoid issues with `<foreignObject>` rendering in Playwright/Chromium, the `MarkdownService` was updated to configure Mermaid with `htmlLabels: false`. This forces Mermaid to use SVG `<text>` elements instead of HTML for labels.

However, when running the `test-pdf-service.mjs` script, which uses `MarkdownService` in a JSDOM environment, Mermaid throws an error during text measurement, specifically because `getComputedTextLength` is not available or not functioning as expected on the SVG text nodes created by JSDOM.

## Attempted Fixes

1.  **Initial Polyfill for `getComputedTextLength`**:
    *   A `fakeGetComputedTextLength` function was added to `test-pdf-service.mjs`.
    *   This function was conditionally applied to `SVGTextContentElement.prototype`, `SVGTSpanElement.prototype`, and `SVGTextElement.prototype` if `getComputedTextLength` was not already present.
    *   **Result**: The error persisted. Console logs indicated the polyfill was not applied, suggesting JSDOM already provided *some* version of `getComputedTextLength` on these prototypes, or the prototypes themselves weren't being accessed correctly via `window[className]`.

2.  **Forced Polyfill Application**:
    *   The polyfill application logic in `test-pdf-service.mjs` was modified to unconditionally overwrite `getComputedTextLength` on the relevant prototypes.
    *   **Result**: The error persisted. New console warnings appeared: `Could not find window.SVGTextContentElement or its prototype to polyfill getComputedTextLength.` (and similar for `SVGTSpanElement` and `SVGTextElement`). This indicated that accessing SVG element constructors/prototypes via `window[className]` was unreliable in the JSDOM setup.

## Hypothesis

The `getComputedTextLength` method, as implemented or stubbed by JSDOM on SVG text-related element prototypes, is either non-functional, returns unexpected values, or is not discoverable/overwritable through the methods previously attempted. Mermaid's text measurement logic for `htmlLabels: false` strictly requires a working `getComputedTextLength`.

A more robust method of accessing the SVG element prototypes (e.g., via `Object.getPrototypeOf(document.createElementNS(...))`) is needed to correctly apply the polyfill. If JSDOM's native `getComputedTextLength` cannot be made to work or be reliably overridden, a more sophisticated polyfill that accurately mimics browser behavior for this function might be necessary, or Mermaid's interaction with JSDOM for text measurement needs deeper investigation.
```
```
## Dependencies

### nodejs_projects/core/src/services/markdown/markdown.service.ts
```typescript
import { marked, Renderer, Tokens } from 'marked';
import mermaid from 'mermaid';
// DOMPurify is no longer imported directly. It's expected to be on globalThis.

const DEFAULT_MARKDOWN_PARSE_OPTIONS: Required<Omit<MarkdownParseOptions, 'mermaidTheme' | 'mermaidSecurityLevel'>> & Pick<MarkdownParseOptions, 'mermaidTheme' | 'mermaidSecurityLevel'> = {
    gfm: true,
    breaks: true,
    headerIds: true,
    sanitizeHtml: true, 
    mermaidTheme: 'default' as MermaidTheme,
    mermaidSecurityLevel: 'loose' as MermaidSecurityLevel,
};

const escape = (html: string, encode?: boolean): string => {
    return html
      .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&')
      .replace(/</g, '<')
      .replace(/>/g, '>')
      .replace(/"/g, '"')
      .replace(/'/g, '\u0027');
};

export class MarkdownService implements IMarkdownService {
    constructor() {
        // JSDOM and global DOMPurify instance should be set up by the environment 
        // (e.g., test script or main application bootstrap) for server-side Mermaid rendering
        // and for the service's own sanitization needs if sanitizeHtml is true.
    }

    public async parse(markdownText: string, options?: MarkdownParseOptions): Promise<string> {
        const mergedOptions = { ...DEFAULT_MARKDOWN_PARSE_OPTIONS, ...options };

        // Ensure globalThis.DOMPurify is available if sanitization is needed by this service or by Mermaid
        const currentDOMPurify = (globalThis as any).DOMPurify;
        if (mergedOptions.sanitizeHtml && (!currentDOMPurify || typeof currentDOMPurify.sanitize !== 'function')) {
            console.warn("MarkdownService: sanitizeHtml is true, but globalThis.DOMPurify.sanitize is not available. HTML will not be sanitized by the service for non-Mermaid code blocks.");
            // Potentially throw an error or disable sanitization for code blocks
        }
        if ((mergedOptions.mermaidSecurityLevel !== 'loose' && mergedOptions.mermaidSecurityLevel !== 'antiscript') && // strict or sandbox
            (!currentDOMPurify || typeof currentDOMPurify.sanitize !== 'function')) {
            // Mermaid will also log an error or fail if it can't find globalThis.DOMPurify.sanitize
            console.warn("MarkdownService: Mermaid security level requires DOMPurify, but globalThis.DOMPurify.sanitize is not available.");
        }


        if (typeof mermaid.initialize === 'function') {
            mermaid.initialize({
                startOnLoad: false,
                theme: mergedOptions.mermaidTheme,
                securityLevel: mergedOptions.mermaidSecurityLevel,
                // Mermaid v11+ uses its imported DOMPurify or globalThis.DOMPurify.
                // The globalThis.DOMPurify should be configured by the environment.
                dompurifyConfig: { 
                    USE_PROFILES: { html: true, svg: true },
                },
                // Pivot to text-only rendering for better PDF compatibility
                flowchart: { htmlLabels: false },
                sequence: { htmlLabels: false } as any, // Bypass TS error, assuming htmlLabels is valid at runtime for v11.6
                state: { htmlLabels: false } as any, // Bypass TS error, assuming htmlLabels is valid at runtime for v11.6
                // Add other diagram types here if they support htmlLabels and need text-only rendering
            });
        }

        const renderer = new Renderer();
        const mermaidPlaceholders: { id: string, code: string, placeholderRegex: RegExp, placeholderString: string }[] = [];

        renderer.code = (token: Tokens.Code): string => {
            const lang = (token.lang || '').toLowerCase();
            if (lang === 'mermaid') {
                const uniqueId = `mermaid-svg-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
                const placeholderString = `<!-- MERMAID_PLACEHOLDER_${uniqueId} -->`;
                mermaidPlaceholders.push({ 
                    id: uniqueId,
                    code: token.text,
                    placeholderRegex: new RegExp(placeholderString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')),
                    placeholderString: placeholderString
                });
                return placeholderString;
            }

            const classAttribute = lang ? ` class="language-${escape(lang, true)}"` : '';
            const codeToDisplay = token.escaped ? token.text : escape(token.text, true);
            let rawHtml = `<pre><code${classAttribute}>${codeToDisplay}\n</code></pre>\n`;
            
            if (mergedOptions.sanitizeHtml && currentDOMPurify && typeof currentDOMPurify.sanitize === 'function') {
                // Use the globally provided DOMPurify instance
                return currentDOMPurify.sanitize(rawHtml, { 
                    USE_PROFILES: { html: true },
                    ADD_TAGS: ['pre', 'code'],
                    ADD_ATTR: ['class']
                });
            }
            // If sanitizeHtml is true but DOMPurify is not available, rawHtml is returned (with a warning logged earlier)
            // If sanitizeHtml is false, rawHtml is returned.
            return rawHtml;
        };
        
        marked.use({ renderer });

        const markedOptions = {
            gfm: mergedOptions.gfm,
            breaks: mergedOptions.breaks,
            headerIds: mergedOptions.headerIds,
            mangle: false,
        };

        let html = await Promise.resolve(marked.parse(markdownText, markedOptions));
        if (typeof html !== 'string') {
            html = String(html);
        }

        if (typeof mermaid.render === 'function' && mermaidPlaceholders.length > 0) {
            for (const item of mermaidPlaceholders) {
                try {
                    const { svg } = await mermaid.render(item.id, item.code);
                    // Mermaid's output (SVG) is assumed to be safe if securityLevel is not 'unsafe',
                    // as it would have used the global DOMPurify.
                    html = html.replace(item.placeholderRegex, `<div class="mermaid">${svg}</div>`);
                } catch (e: any) {
                    console.error(`Mermaid rendering error for diagram starting with "${item.code.substring(0, 30)}...":`, e);
                    const errorHtml = `<pre class="mermaid-error" data-mermaid-id="${item.id}">Mermaid Error: ${escape(e.message || String(e))}</pre>`;
                    html = html.replace(item.placeholderRegex, errorHtml);
                }
            }
        } else if (mermaidPlaceholders.length > 0) {
            console.warn("Mermaid.render function not available or no diagrams to render. Mermaid diagrams will not be processed.");
            for (const item of mermaidPlaceholders) {
                const notice = `<div class="mermaid-render-unavailable" data-mermaid-id="${item.id}">Mermaid rendering is unavailable. Diagram code: <pre>${escape(item.code)}</pre></div>`;
                html = html.replace(item.placeholderRegex, notice);
            }
        }
        
        return html;
    }
}
### nodejs_projects/core/scripts/test-pdf-service.mjs
```javascript
import { PdfService, MarkdownService } from '../dist/esm/index.js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { JSDOM } from 'jsdom';
import * as DOMPurifyModule from 'dompurify'; // For MarkdownService

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Setup based on learnings_mermaid_dompurify_nodejs.md and bootstrap-mermaid.mjs
async function setupMarkdownServiceDependencies() {
  console.log("Setting up JSDOM, DOMPurify, and polyfills for MarkdownService...");
  
  const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
    pretendToBeVisual: true,
    runScripts: "dangerously",
    resources: "usable"
  });
  const window = dom.window; // JSDOM window
  const document = window.document; // Use this for creating elements
  
  // Globalize JSDOM properties
  globalThis.window = window;
  globalThis.document = window.document;
  globalThis.navigator = { userAgent: 'node.js' };

  // Explicit Globalization of DOM Types from JSDOM's window
  if (typeof window.Element !== 'undefined') globalThis.Element = window.Element;
  if (typeof window.HTMLElement !== 'undefined') globalThis.HTMLElement = window.HTMLElement;
  if (typeof window.SVGElement !== 'undefined') globalThis.SVGElement = window.SVGElement;
  if (typeof window.Node !== 'undefined') globalThis.Node = window.Node;
  if (typeof window.DocumentFragment !== 'undefined') globalThis.DocumentFragment = window.DocumentFragment;
  if (typeof window.DOMParser !== 'undefined') globalThis.DOMParser = window.DOMParser;
  if (typeof window.XMLSerializer !== 'undefined') globalThis.XMLSerializer = window.XMLSerializer;
  // Ensure other SVG types are globalized if needed by fakeBBox application
  if (typeof window.SVGGraphicsElement !== 'undefined') globalThis.SVGGraphicsElement = window.SVGGraphicsElement;
  if (typeof window.SVGSVGElement !== 'undefined') globalThis.SVGSVGElement = window.SVGSVGElement;
  if (typeof window.SVGTextElement !== 'undefined') globalThis.SVGTextElement = window.SVGTextElement;
  if (typeof window.SVGTextContentElement !== 'undefined') globalThis.SVGTextContentElement = window.SVGTextContentElement;
  if (typeof window.SVGTSpanElement !== 'undefined') globalThis.SVGTSpanElement = window.SVGTSpanElement; // For getComputedTextLength

  // `fakeBBox` Polyfill (refined to handle CSS in textContent)
  function fakeBBox() {
    const textContent = this.textContent || '';
    let len = textContent.length;
    let isCSSBlock = false;

    // Heuristic: If textContent is very long and looks like CSS, don't use its length for sizing.
    if (len > 500 && (textContent.includes('@keyframes') || textContent.includes('font-family') || textContent.includes('stroke-dasharray'))) {
      console.log(`fakeBBox for ${this.tagName || 'unknown'}: Detected CSS-like content in textContent. Length ${len} will be treated as 0 for sizing.`);
      len = 0; // Calculate bbox as if there's no text.
      isCSSBlock = true;
    }

    const estimatedCharWidth = 8; 
    const padding = 10; 
    const w = Math.max(estimatedCharWidth * len + padding, 40); // Min width 40
    const h = Math.max(18, 18); // Min height 18
    
    const logText = isCSSBlock ? "[CSS Block]" : textContent.substring(0,70); // Increased substring for better context

    console.log(`fakeBBox for ${this.tagName || 'unknown'}: text: "${logText}..." (orig length: ${textContent.length}, used length: ${len}) -> width: ${w}, height: ${h}`);
    return { x: 0, y: 0, width: w, height: h, top: 0, left: 0, right: w, bottom: h };
  }

  // Apply fakeBBox to JSDOM's window SVG element prototypes
  const svgElementClassesForBBox = ['SVGElement', 'SVGGraphicsElement', 'SVGSVGElement', 'SVGTextElement', 'SVGTextContentElement', 'SVGTSpanElement'];
  svgElementClassesForBBox.forEach(className => {
    if (window[className] && window[className].prototype && !window[className].prototype.getBBox) {
      window[className].prototype.getBBox = fakeBBox;
      console.log(`Applied fakeBBox to window.${className}.prototype`);
    } else if (window[className] && window[className].prototype && window[className].prototype.getBBox && window[className].prototype.getBBox !== fakeBBox) {
      // console.log(`window.${className}.prototype.getBBox already exists. Overwriting with fakeBBox.`);
      // window[className].prototype.getBBox = fakeBBox; // Uncomment to force overwrite if JSDOM's version is problematic
    }
  });

  // `getComputedTextLength` Polyfill
  function fakeGetComputedTextLength() {
    const text = this.textContent || '';
    const charCount = text.length;
    const estimatedCharWidth = 8; 
    const computedLength = charCount * estimatedCharWidth;
    // Truncate long text in log
    const logText = text.length > 70 ? text.substring(0,70) + "..." : text;
    console.log(`fakeGetComputedTextLength for text: "${logText}" (charCount: ${charCount}) -> computedLength: ${computedLength}`);
    return computedLength;
  }

  // More robustly apply getComputedTextLength to relevant SVG element prototypes
  console.log("Attempting to polyfill getComputedTextLength...");

  try {
    const svgTextElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    const svgTSpanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');

    const textElementProto = Object.getPrototypeOf(svgTextElement);
    const tspanElementProto = Object.getPrototypeOf(svgTSpanElement);
    
    if (textElementProto && typeof textElementProto.getComputedTextLength !== 'function') {
      textElementProto.getComputedTextLength = fakeGetComputedTextLength;
      console.log("Polyfilled getComputedTextLength on SVGTextElement prototype.");
    } else if (textElementProto && textElementProto.getComputedTextLength !== fakeGetComputedTextLength) {
      console.log("Overwriting existing getComputedTextLength on SVGTextElement prototype.");
      textElementProto.getComputedTextLength = fakeGetComputedTextLength;
    } else if (textElementProto) {
      console.log("getComputedTextLength already exists and matches polyfill on SVGTextElement prototype (or was already polyfilled).");
    } else {
      console.warn("Could not get SVGTextElement prototype to polyfill getComputedTextLength.");
    }

    if (tspanElementProto && typeof tspanElementProto.getComputedTextLength !== 'function') {
      tspanElementProto.getComputedTextLength = fakeGetComputedTextLength;
      console.log("Polyfilled getComputedTextLength on SVGTSpanElement prototype.");
    } else if (tspanElementProto && tspanElementProto.getComputedTextLength !== fakeGetComputedTextLength) {
      console.log("Overwriting existing getComputedTextLength on SVGTSpanElement prototype.");
      tspanElementProto.getComputedTextLength = fakeGetComputedTextLength;
    } else if (tspanElementProto) {
      console.log("getComputedTextLength already exists and matches polyfill on SVGTSpanElement prototype (or was already polyfilled).");
    } else {
      console.warn("Could not get SVGTSpanElement prototype to polyfill getComputedTextLength.");
    }

  } catch (e) {
    console.error("Error during getComputedTextLength polyfill application:", e);
  }


  // Unified DOMPurify Instance and Patching (consistent with bootstrap-mermaid.mjs logic)
  let actualCreateDOMPurifyFactory;
  if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    actualCreateDOMPurifyFactory = DOMPurifyModule.default;
  } else if (typeof DOMPurifyModule === 'function') { // Less common, namespace is factory
    actualCreateDOMPurifyFactory = DOMPurifyModule;
  } else {
    console.error("CRITICAL - Could not reliably identify a DOMPurify factory function.");
    actualCreateDOMPurifyFactory = DOMPurifyModule.default || DOMPurifyModule; 
    if (!actualCreateDOMPurifyFactory || typeof actualCreateDOMPurifyFactory !== 'function') {
        throw new Error("Failed to resolve DOMPurify factory or it's not a function.");
    }
  }
  
  const DOMPurifyInstance = actualCreateDOMPurifyFactory(window); // Use JSDOM window

  const globalDOMPurifyShim = {
    sanitize: (...args) => DOMPurifyInstance.sanitize(...args),
    addHook: (...args) => DOMPurifyInstance.addHook ? DOMPurifyInstance.addHook(...args) : (() => { console.warn("DOMPurifyInstance.addHook not available"); })(),
    removeHook: (...args) => DOMPurifyInstance.removeHook ? DOMPurifyInstance.removeHook(...args) : (() => { console.warn("DOMPurifyInstance.removeHook not available"); })(),
    removeAllHooks: (...args) => DOMPurifyInstance.removeAllHooks ? DOMPurifyInstance.removeAllHooks(...args) : (() => { console.warn("DOMPurifyInstance.removeAllHooks not available"); })(),
    version: DOMPurifyModule.version || actualCreateDOMPurifyFactory.version || DOMPurifyInstance.version || 'unknown',
    isSupported: DOMPurifyModule.isSupported !== undefined ? DOMPurifyModule.isSupported : (actualCreateDOMPurifyFactory.isSupported !== undefined ? actualCreateDOMPurifyFactory.isSupported : (DOMPurifyInstance.isSupported !== undefined ? DOMPurifyInstance.isSupported : true)),
  };

  globalThis.DOMPurify = globalDOMPurifyShim;

  // Patch the imported module itself to ensure consistency if Mermaid imports 'dompurify' directly.
  if (DOMPurifyModule.default && typeof DOMPurifyModule.default === 'function') {
    DOMPurifyModule.default.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    if (typeof DOMPurifyInstance.addHook === 'function') DOMPurifyModule.default.addHook = (...args) => DOMPurifyInstance.addHook(...args);
  } else if (typeof DOMPurifyModule === 'function') { 
    DOMPurifyModule.sanitize = (...args) => DOMPurifyInstance.sanitize(...args);
    if (typeof DOMPurifyInstance.addHook === 'function') DOMPurifyModule.addHook = (...args) => DOMPurifyInstance.addHook(...args);
  }
  console.log("DOMPurify instance created, shimmed to globalThis, and imported module patched.");
  
  console.log("JSDOM, DOMPurify, and polyfills for MarkdownService setup complete.");
}


async function main() {
  try {
    await setupMarkdownServiceDependencies(); 

    console.log('Testing PdfService with PlaywrightPdfEngine...');
    
    const markdownService = new MarkdownService(); 
    const pdfService = new PdfService(markdownService);

    // Using the more complex diagram to test robustness
    const comprehensiveMarkdown = `
# Markdown Feature Test

## 1. Headings
# H1 Heading  
## H2 Heading  

---

## 13. Mermaid Diagram (Original)

\`\`\`mermaid
graph TD
    A[Start] --> B{Is it working?}
    B -- Yes --> C[Great!]
    B -- No --> D[Fix it]
    D --> B
\`\`\`

---
## Simplified Mermaid Diagram (for comparison if needed)

\`\`\`mermaid
graph TD
    S[Simple Start] --> E[Simple End]
\`\`\`

`;


    const testHtml = `
<h1>Test HTML PDF (Playwright)</h1>
<p>This is a test directly from an HTML string using Playwright.</p>
<p>With an inline SVG:</p>
<svg width="100" height="100" id="test-svg-element">
  <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" id="test-circle-element" />
  <rect x="10" y="10" width="30" height="30" fill="blue" id="test-rect-element" />
  <image href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" x="0" y="0" height="10" width="10"/>
</svg>
<p>And some math: $$ E = mc^2 $$</p>
<p>Another paragraph.</p>`;

    console.log('\nGenerating PDF from Markdown...');
    const htmlFromMarkdown = await markdownService.parse(comprehensiveMarkdown);
    const debugHtmlPath = path.join(__dirname, 'debug_markdown_service_output.html');
    await fs.writeFile(debugHtmlPath, htmlFromMarkdown);
    console.log(`Full HTML from MarkdownService saved to ${debugHtmlPath}`);
    
    const markdownPdfBlob = await pdfService.generatePdfFromHtml(htmlFromMarkdown, {
      filename: 'test_markdown_playwright.pdf',
      margins: { top: 15, right: 15, bottom: 15, left: 15 },
      pageFormat: 'a4'
    });
    const markdownPdfBuffer = Buffer.from(await markdownPdfBlob.arrayBuffer());
    const markdownOutputPath = path.join(__dirname, 'test_markdown_playwright_output.pdf');
    await fs.writeFile(markdownOutputPath, markdownPdfBuffer);
    console.log(`Markdown PDF saved to ${markdownOutputPath}`);

    console.log('\nGenerating PDF from HTML...');
    const htmlPdfBlob = await pdfService.generatePdfFromHtml(testHtml, {
      filename: 'test_html_playwright.pdf',
      margins: { top: 20, right: 20, bottom: 20, left: 20 },
      pageFormat: 'letter',
      orientation: 'landscape'
    });
    const htmlPdfBuffer = Buffer.from(await htmlPdfBlob.arrayBuffer());
    const htmlOutputPath = path.join(__dirname, 'test_html_playwright_output.pdf');
    await fs.writeFile(htmlOutputPath, htmlPdfBuffer);
    console.log(`HTML PDF saved to ${htmlOutputPath}`);

    console.log('\nTest script finished successfully.');
  } catch (error) {
    console.error('Error during PdfService test (Playwright):');
    console.error('Error Name:', error.name);
    console.error('Error Message:', error.message);
    if (error.stack) {
        console.error('Error Stack:', error.stack);
    }
    if (error.cause) { 
        console.error('Error Cause:', error.cause);
    }
    process.exit(1);
  }
}

main();
```
### nodejs_projects/core/src/services/pdf/playwright.engine.ts
```typescript
// Buffer is expected to be a global type from @types/node
import { IPdfEngine } from './pdf-engine.interface.js';
import { PdfGenerationOptions } from './pdf.types.js';
import { chromium, Browser, Page, errors as PlaywrightErrors } from 'playwright';

export class PlaywrightPdfEngine implements IPdfEngine {
  public async generate(html: string, options: PdfGenerationOptions): Promise<Blob> {
    console.log('PlaywrightPdfEngine.generate called with options:', options);
    let browser: Browser | null = null;
    try {
      browser = await chromium.launch();
      const context = await browser.newContext();
      const page: Page = await context.newPage();

      // Forward browser console logs to Node console for easier debugging
      page.on('console', msg => {
        const type = msg.type();
        const text = msg.text();
        if (text.startsWith('[Playwright DOM Correction]')) {
          console.log(`Playwright Browser Console (${type}): ${text}`);
        } else if (type === 'error' || type === 'warn') {
          console.log(`Playwright Browser Console (${type}): ${text}`);
        }
      });

      await page.setContent(html, { waitUntil: 'domcontentloaded' });

      // Inject script to correct SVG issues before PDF generation
      await page.evaluate(() => {
        const logPrefix = '[Playwright DOM Correction]';

        // 1. Correct <foreignObject> dimensions
        // This section is currently SKIPPED because Mermaid is configured with htmlLabels: false,
        // which should prevent the use of <foreignObject> for labels.
        // If issues with <foreignObject> reappear, this section may need to be re-enabled.
        console.log(`${logPrefix} Skipping <foreignObject> correction due to htmlLabels:false pivot.`);
        /*
        const foreignObjects = document.querySelectorAll('.mermaid svg foreignObject');
        console.log(`${logPrefix} Found ${foreignObjects.length} foreignObject elements.`);
        foreignObjects.forEach((el: Element, index: number) => {
          const fo = el as SVGForeignObjectElement; // Cast to SVGForeignObjectElement
          const currentWidth = fo.getAttribute('width');
          const currentHeight = fo.getAttribute('height');

          if (currentWidth === '0' || currentHeight === '0' || !currentWidth || !currentHeight) {
            const foChild = fo.firstElementChild as HTMLElement;
            if (foChild) {
              // Ensure styles are applied and element is in a state to be measured
              // Reading a property like offsetWidth can force a reflow if needed.
              foChild.offsetWidth; 

              const newWidth = Math.max(foChild.scrollWidth, 1);
              const newHeight = Math.max(foChild.scrollHeight, 1);

              if (newWidth > 0 && newHeight > 0) {
                fo.setAttribute('width', String(newWidth));
                fo.setAttribute('height', String(newHeight));
                console.log(`${logPrefix} Resized foreignObject #${index} (ID: ${fo.id || 'N/A'}) from ${currentWidth}x${currentHeight} to ${newWidth}x${newHeight}`);
              } else {
                console.warn(`${logPrefix} Could not determine valid dimensions for foreignObject child of #${index} (ID: ${fo.id || 'N/A'}). Child:`, foChild);
              }
            } else {
              console.warn(`${logPrefix} ForeignObject #${index} (ID: ${fo.id || 'N/A'}) has no child element to measure.`);
            }
          }
        });
        */

        // 2. Correct NaN transforms
        const elementsWithNanTransform = document.querySelectorAll('.mermaid svg [transform*="NaN"]');
        console.log(`${logPrefix} Found ${elementsWithNanTransform.length} elements with NaN in transform.`);
        elementsWithNanTransform.forEach((element: Element) => {
          const el = element as SVGElement; // Cast to SVGElement
          const currentTransform = el.getAttribute('transform');
          console.warn(`${logPrefix} Fixing NaN transform "${currentTransform}" for element:`, el.id || el.tagName);
          if (currentTransform && currentTransform.toLowerCase().startsWith('translate(')) {
            el.setAttribute('transform', 'translate(0,0)');
          } else {
            el.removeAttribute('transform');
          }
        });

        // 3. Adjust SVG viewBox
        const mermaidSvgs = document.querySelectorAll('.mermaid svg');
        console.log(`${logPrefix} Found ${mermaidSvgs.length} Mermaid SVG elements to check viewBox.`);
        mermaidSvgs.forEach((element: Element) => {
          const svg = element as SVGSVGElement; // Cast to SVGSVGElement
          try {
            // Ensure all previous DOM manipulations are processed by the renderer
            svg.getBoundingClientRect(); // Reading a property can trigger layout updates

            const bbox = svg.getBBox(); // Get bounding box from browser's rendering engine

            if (bbox && bbox.width > 0 && bbox.height > 0) {
              const currentViewBoxAttr = svg.getAttribute('viewBox');
              let initialMinX = bbox.x, initialMinY = bbox.y;

              if (currentViewBoxAttr) {
                  const parts = currentViewBoxAttr.split(' ').map(Number);
                  if (parts.length === 4) {
                      // Prefer existing viewBox origin if it provides padding
                      initialMinX = Math.min(parts[0], bbox.x);
                      initialMinY = Math.min(parts[1], bbox.y);
                  }
              }
              
              const padding = 5; // Add 5 units of padding around the content
              const finalMinX = bbox.x - padding;
              const finalMinY = bbox.y - padding;
              const finalWidth = bbox.width + (padding * 2);
              const finalHeight = bbox.height + (padding * 2);

              const newViewBox = `${finalMinX} ${finalMinY} ${finalWidth} ${finalHeight}`;
              
              // Only update if it's meaningfully different or fixes a clearly invalid viewBox
              let oldHeight = 0;
              if(currentViewBoxAttr) {
                const oldParts = currentViewBoxAttr.split(' ').map(Number);
                if(oldParts.length === 4) oldHeight = oldParts[3];
              }

              if (newViewBox !== currentViewBoxAttr && (finalHeight > oldHeight || oldHeight < 16 /* arbitrary small number */)) {
                svg.setAttribute('viewBox', newViewBox);
                console.log(`${logPrefix} Corrected SVG viewBox for ${svg.id || 'svg'}. Old: "${currentViewBoxAttr}". New: "${newViewBox}". BBox was: x:${bbox.x}, y:${bbox.y}, w:${bbox.width}, h:${bbox.height}`);
              }
            } else {
                 const currentViewBoxAttr = svg.getAttribute('viewBox');
                 console.warn(`${logPrefix} SVG ${svg.id || 'svg'} has zero or invalid bbox (w:${bbox.width}, h:${bbox.height}) after fixes. Original viewBox: ${currentViewBoxAttr}`);
            }
          } catch (e: any) {
            console.error(`${logPrefix} Error processing SVG viewBox for ${svg.id || 'svg'}: ${e.message}`, e);
          }
        });
        console.log(`${logPrefix} DOM corrections applied (foreignObject part skipped).`);
      });

      // Add a small delay if needed for any asynchronous updates post-evaluate, though usually not necessary
      // await page.waitForTimeout(100); 

      const playwrightPdfOptions: any = {
        format: options.pageFormat || 'A4',
        landscape: options.orientation === 'landscape',
        scale: options.scale || 1,
        margin: {
          top: options.margins?.top ? `${options.margins.top}mm` : '10mm',
          right: options.margins?.right ? `${options.margins.right}mm` : '10mm',
          bottom: options.margins?.bottom ? `${options.margins.bottom}mm` : '10mm',
          left: options.margins?.left ? `${options.margins.left}mm` : '10mm',
        },
        printBackground: options.printBackground === undefined ? true : options.printBackground,
      };

      if (options.width) {
        playwrightPdfOptions.width = options.width;
      }
      if (options.height) {
        playwrightPdfOptions.height = options.height;
      }
      if (options.path) {
        playwrightPdfOptions.path = options.path;
      }

      // For debugging, take a screenshot before PDF generation
      // if (options.path) {
      //   const screenshotPath = options.path.replace('.pdf', '_debug.png');
      //   await page.screenshot({ path: screenshotPath, fullPage: true });
      //   console.log(`Debug screenshot saved to ${screenshotPath}`);
      // }

      const pdfBuffer: Buffer = await page.pdf(playwrightPdfOptions);

      await browser.close();
      browser = null;

      return new Blob([pdfBuffer], { type: 'application/pdf' });

    } catch (error) {
      console.error('Error in PlaywrightPdfEngine.generate:', error);
      if (browser) {
        try {
          await browser.close();
        } catch (closeError) {
          console.error('Error closing browser after an initial error:', closeError);
        }
      }
      if (error instanceof PlaywrightErrors.TimeoutError) {
        throw new Error(`Playwright timed out: ${error.message}`);
      }
      throw new Error(`Failed to generate PDF with Playwright: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}
```
### nodejs_projects/core/src/services/pdf/playwright-dom-correction.js
```javascript
// This script will be executed in the browser context by Playwright
const logPrefix = '[Playwright DOM Correction]';
console.log(`${logPrefix} Starting DOM corrections for Mermaid SVGs.`);

// --- Step 1: Identify and mark edgeLabel groups with NaN transforms ---
const edgeLabelGroupsToHide = new Set();
document.querySelectorAll('.mermaid svg g.edgeLabel').forEach((elGroup) => {
  const transformAttr = elGroup.getAttribute('transform');
  if (transformAttr && transformAttr.includes('NaN')) {
    edgeLabelGroupsToHide.add(elGroup);
    (elGroup).setAttribute('transform', 'translate(0,0)');
    console.warn(`${logPrefix} Marked g.edgeLabel (ID: ${elGroup.id || 'N/A'}) for hiding due to original NaN transform: ${transformAttr}`);
  }
});

// --- Step 2: Resize foreignObjects and adjust content styling ---
document.querySelectorAll('.mermaid svg foreignObject').forEach((foNode, index) => {
  const fo = foNode;
  const currentWidthAttr = fo.getAttribute('width');
  const currentHeightAttr = fo.getAttribute('height');
  const foIsLikelyZeroSizeOnAttribute = currentWidthAttr === '0' || currentHeightAttr === '0' || !currentWidthAttr || !currentHeightAttr;

  const foChild = fo.firstElementChild;
  if (!foChild) {
    console.warn(`${logPrefix} FO #${index} (ID: ${fo.id || 'N/A'}) has no child. Setting to 1x1.`);
    fo.setAttribute('width', '1');
    fo.setAttribute('height', '1');
    return;
  }

  const parentNodeGroup = fo.closest('g.node');
  const parentEdgeLabelGroup = fo.closest('g.edgeLabel');

  if (parentEdgeLabelGroup && edgeLabelGroupsToHide.has(parentEdgeLabelGroup)) {
    console.log(`${logPrefix} FO #${index} (ID: ${fo.id || 'N/A'}) is in a g.edgeLabel marked for hiding. Setting visibility:hidden and size 1x1.`);
    (fo).style.visibility = 'hidden';
    if (foChild instanceof HTMLElement) {
        (foChild).style.visibility = 'hidden';
    }
    fo.setAttribute('width', '1');
    fo.setAttribute('height', '1');
    return;
  }

  let newWidth = 1, newHeight = 1;

  if (!(foChild instanceof HTMLElement)) {
    console.warn(`${logPrefix} foChild of FO #${index} (ID: ${fo.id || 'N/A'}) is not HTMLElement. Using 1x1. Child type: ${foChild.constructor.name}`);
    fo.setAttribute('width', '1');
    fo.setAttribute('height', '1');
    return;
  }

  // **Universal Temporary Width Fix for Zero-Width FOs**
  // If the foreignObject itself has an explicit or computed width of "0" or "auto",
  // its child (foChild) might calculate a scrollWidth of nearly zero.
  // Temporarily give it a useful width for accurate measurement.
  const originalFOExplicitWidth = fo.getAttribute('width'); // Re-read, might differ from currentWidthAttr if it was null
  let foComputedStyle = window.getComputedStyle(fo);
  let foWidthTemporarilySet = false;

  if (originalFOExplicitWidth === '0' || !originalFOExplicitWidth || foComputedStyle.width === '0px' || foComputedStyle.width === 'auto') {
      fo.setAttribute('width', '1000px'); // Temporary large width
      foWidthTemporarilySet = true;
      // console.log(`${logPrefix} FO #${index} (ID: ${fo.id || 'N/A'}) had effective zero/auto width. Temp set to 1000px before type-specific styling.`);
  }

  const isNodeLabel = parentNodeGroup && !parentEdgeLabelGroup;
  const isVisibleEdgeLabel = parentEdgeLabelGroup; // (and not in edgeLabelGroupsToHide)

  if (isNodeLabel) {
    // console.log(`${logPrefix} Processing FO #${index} (ID: ${fo.id || 'N/A'}) as NODE LABEL.`);
    foChild.style.whiteSpace = 'normal';
    foChild.style.overflowWrap = 'anywhere';
    foChild.style.textAlign = 'center'; // <--- UNCOMMENTED THIS LINE
  } else if (isVisibleEdgeLabel) {
    // console.log(`${logPrefix} Processing FO #${index} (ID: ${fo.id || 'N/A'}) as VISIBLE EDGE LABEL.`);
    // No change to white-space needed; let Mermaid's CSS for edge labels apply (usually nowrap).
  } else {
    // console.log(`${logPrefix} Processing FO #${index} (ID: ${fo.id || 'N/A'}) as OTHER foreignObject.`);
  }

  foChild.offsetWidth; // Force reflow after style changes and potential temporary FO width.
  newWidth = Math.max(foChild.scrollWidth, 1);
  newHeight = Math.max(foChild.scrollHeight, 1);

  fo.setAttribute('width', String(newWidth));
  fo.setAttribute('height', String(newHeight));

  if (foIsLikelyZeroSizeOnAttribute || String(newWidth) !== currentWidthAttr || String(newHeight) !== currentHeightAttr) {
    const sizeChangeType = foIsLikelyZeroSizeOnAttribute ? 'Resized' : 'Adjusted';
    const foType = isNodeLabel ? 'NodeLabel' : isVisibleEdgeLabel ? 'VisibleEdgeLabel' : 'Other';
    console.log(`${logPrefix} ${sizeChangeType} FO #${index} (ID: ${fo.id || 'N/A'}) from ${currentWidthAttr}x${currentHeightAttr} to ${newWidth}x${newHeight}. Type: ${foType}${foWidthTemporarilySet ? ' (temp width was applied)' : ''}`);
  }
});

// --- Step 3: Hide the edgeLabel groups that originally had NaN transforms ---
edgeLabelGroupsToHide.forEach((elGroup) => {
  (elGroup).style.visibility = 'hidden';
  console.log(`${logPrefix} Set visibility:hidden for g.edgeLabel (ID: ${elGroup.id || 'N/A'})`);
});

// --- Step 4: Adjust SVG viewBox to fit the (now modified) content ---
document.querySelectorAll('.mermaid svg').forEach((svgNode) => {
  const svg = svgNode;
  try {
    svg.getBoundingClientRect();
    const bbox = svg.getBBox();

    if (bbox && bbox.width > 0 && bbox.height > 0) {
      const currentViewBoxAttr = svg.getAttribute('viewBox');
      const padding = 10;
      const finalMinX = bbox.x - padding;
      const finalMinY = bbox.y - padding;
      const finalWidth = bbox.width + (padding * 2);
      const finalHeight = bbox.height + (padding * 2);
      const newViewBox = `${finalMinX} ${finalMinY} ${finalWidth} ${finalHeight}`;
      
      let oldHeight = 0, oldWidth = 0;
      if (currentViewBoxAttr) {
        const oldParts = currentViewBoxAttr.split(' ').map(Number);
        if (oldParts.length === 4) { oldWidth = oldParts[2]; oldHeight = oldParts[3]; }
      }

      const significantChangeFactor = 0.9;
      const sizeThreshold = 30;
      if (newViewBox !== currentViewBoxAttr && 
          (finalHeight < oldHeight * significantChangeFactor || finalHeight > oldHeight / significantChangeFactor || oldHeight < sizeThreshold ||
           finalWidth < oldWidth * significantChangeFactor || finalWidth > oldWidth / significantChangeFactor || oldWidth < sizeThreshold)) {
        svg.setAttribute('viewBox', newViewBox);
        console.log(`${logPrefix} Corrected SVG viewBox for ${svg.id || 'svg'}. Old: "${currentViewBoxAttr}". New: "${newViewBox}". BBox was: x:${bbox.x}, y:${bbox.y}, w:${bbox.width}, h:${bbox.height}`);
      } else {
        // console.log(`${logPrefix} SVG viewBox for ${svg.id || 'svg'} not changed significantly. Current: "${currentViewBoxAttr}", BBox (no padding): w:${bbox.width}, h:${bbox.height}`);
      }
    } else {
      console.warn(`${logPrefix} SVG ${svg.id || 'svg'} has zero/invalid bbox (w:${bbox?.width}, h:${bbox?.height}) after fixes. Original viewBox: ${svg.getAttribute('viewBox')}`);
    }
  } catch (e) {
    const error = e;
    console.error(`${logPrefix} Error processing SVG viewBox for ${svg.id || 'svg'}: ${error.message}`, error);
  }
});

console.log(`${logPrefix} DOM corrections completed.`);
```
```
```
```
```
```
```
```